<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Making stuff after office hours]]></title><description><![CDATA[Making stuff after office hours]]></description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Making stuff after office hours</title><link>http://localhost:2368/</link></image><generator>Ghost 5.24</generator><lastBuildDate>Wed, 30 Nov 2022 16:20:22 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[What do people like to 3D print?]]></title><description><![CDATA[I used Python "Requests" module and Thingiverse's REST API to analyze the popularity of different categories of files for 3D printing]]></description><link>http://localhost:2368/what-people-like-to-3d-print/</link><guid isPermaLink="false">63833b05d5ad1711f85d12e5</guid><category><![CDATA[3dprinting]]></category><category><![CDATA[Data]]></category><category><![CDATA[Python]]></category><category><![CDATA[DataAnalysis]]></category><category><![CDATA[Maker]]></category><dc:creator><![CDATA[Luis Medina]]></dc:creator><pubDate>Wed, 30 Nov 2022 16:14:58 GMT</pubDate><media:content url="http://localhost:2368/content/images/2022/11/IMG_1462.jpg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><h3 id="what-are-the-most-popular-types-of-objects-for-3d-printing">What are the most popular types of objects for 3d printing?</h3>
<img src="http://localhost:2368/content/images/2022/11/IMG_1462.jpg" alt="What do people like to 3D print?"><p>It&#x2019;s been more than a month since the last post. Recently, I have been busy making stuff and not writing about it - which is kinda against the whole idea behind this blog.</p>
<p>Around this time last year, my girlfriend and I created an Instagram account (<a href="https://www.instagram.com/twothingies/">@TwoThingies</a>) to share the things we make with 3D printing at home. It&#x2019;s been a fun journey since we started with the project and for sure I&#x2019;ll write something about it later on in a different post. But for this one, let&#x2019;s stay with the themes of Python and Data Analytics.</p>
<p>I&#x2019;ve also been completing <a href="https://www.coursera.org/professional-certificates/google-data-analytics">Google&#x2019;s Data Analytics Professional Certificate</a> so I thought it would be interesting to do something practical with what I&#x2019;m learning. I decided to do some research about the trends in popular files for 3D printing, what types of objects are more popular, and by how much. This is, of course, an excuse to use some Python and analytics skills with real-world, non-automotive-related data. But I also was genuinely curious about the preferences of 3D printing enthusiasts.</p>
<h2 id="thingiverse-statistics-with-python">Thingiverse statistics with Python</h2>
<p>The first point was to find out what are the most popular things people print at home. I&apos;m talking about makers and hobbyists. Both casual users and people who 3D print a lot of things. Not professional users working with additive manufacturing within specific industries.</p>
<p>For industrial and professional users, there are different sources of information giving some insights. For instance, companies like <a href="https://formlabs.com/3d-printing-applications-report-2022/">FormLabs</a>, <a href="https://www.hubs.com/get/trends/">3DHubs</a>, <a href="https://www.makerbot.com/stories/news/makerbot-pro-3d-printing-trend-report-2020/">MakerBot</a> and <a href="https://www.sculpteo.com/en/ebooks/state-of-3d-printing-report-2021/">Sculpteo</a>, and media platforms like <a href="https://www.3dnatives.com/en/wohlers-report-2021-180320214/">3D Natives</a> have released annual surveys with their findings about trends in the Additive Manufacturing industry itself, or in the use of 3D printing within other industries.</p>
<p>Home or hobby usage, instead, is more difficult to measure. The obvious answer was: go to the source. I wanted to analyze the data from the platforms people use to obtain and share files for personal use or very small businesses.</p>
<p>There are many sites where people get their 3D-printable files online, but the biggest one is - by far - <a href="https://www.thingiverse.com/">Thingiverse.com</a>. Tens of millions of people visit the site every month, and, according to a quick search on <a href="https://www.similarweb.com/website/thingiverse.com/#traffic">SimilarWeb</a>, that is more than 3 times the monthly traffic for the closest competitor, <a href="https://cults3d.com/">Cults3D.com</a>. Even though <strong>Thingiverse is dying due to a lack of proper maintenance and other issues</strong>, it is still by far the most popular site for sharing 3d printable models. Also, its the only platform for sharing 3D print files having an open <a href="https://www.redhat.com/en/topics/api/what-is-a-rest-api">REST API</a>  one can access to collect data about all the models uploaded to the site. Thus, I figured I could use it as a representative sample to find what people are 3d printing.</p>
<h3 id="findings">Findings</h3>
<p>Using Python&#x2019;s <a href="https://pypi.org/project/requests/0.9.0/">&#x201C;requests&#x201D; module</a>, and  <a href="https://www.thingiverse.com/developers/rest-api-reference">Thingiverse&#x2019;s REST API</a>, I found out that <strong>by October 30th, 2022, there were 2155435 published models on the site</strong>. If you are curious to see how I gathered all the data, <a href="https://gist.github.com/luisdamed/f3e262971211184f232cea8553729a85">check out the code I used</a>.</p>
<p>There were also:</p>
<ul>
<li>75539318 likes</li>
<li>875899 &#x201C;makes&#x201D;</li>
<li>3144710 comments</li>
<li>And there were at least 6304142 registered users - there&#x2019;s no direct way to know how many of them are active on the platform - might be an interesting analysis for later.</li>
</ul>
<p>The models are subdivided into 10 main categories, and I was curious to know how many models belonged to each one. So I made a pie plot to represent their share of the total number of likes, makes and published things on the platform.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><iframe width="900" height="450" frameborder="0" scrolling="no" src="PieChart_Python_Pygal_Thingiverse_Categories_Condensed.html"></iframe><!--kg-card-end: html--><!--kg-card-begin: markdown--><p>We can see that &#x201C;3D-printing&#x201D; and &#x201C;Household&#x201D; are by far the largest ones, with 22 and 20% of the total number of models published on the site belonging to them, respectively.</p>
<p>Next, I wanted to know how popular those categories are among users. To measure that, I could compare different indicators of user interaction. On Thingiverse, people can interact with a published model by giving it a like, downloading it, publishing a &#x201C;make&#x201D; (picture of the part they 3D printed using the files), commenting on it, and saving it on a collection.</p>
<p>The only way to know for sure whether a file has actually been printed is by looking at the &#x201C;makes&#x201D; published for that file. But I wonder how many people who download the files and print them actually go and publish a picture of their print. I&#x2019;m guessing not a lot.</p>
<p>To find out, I analyzed the total number of published models, to see what portion of them have at least 1 make published. It turned out that <strong>there&#x2019;s only an 11% chance that users will publish at least one make for a published model</strong>.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><iframe width="900" height="450" frameborder="0" scrolling="no" src="PieChart_Python_Pygal_Thingiverse_1Make.html"></iframe><!--kg-card-end: html--><!--kg-card-begin: markdown--><p>Anyways, I wanted to know what categories are more popular in terms of published makes. This brings another issue:</p>
<p>Having different numbers of models, I cannot compare <em>directly</em> the number of makes among the different categories. If you put a bunch of bins of different sizes next to each other and randomly throw plastic balls at them, the larger bins will end up with more spheres, just because they are larger. The categories here are &#x201C;bins&#x201D; of different sizes. Having more makes, likes or comments on one of them does not necessarily indicate that it is more popular than the others among people using the platform to get their files, not publishing.</p>
<p>I needed to account for the size of each category in order to make a fair comparison. To do that, I divided the number of makes of each category by the number of models uploaded to that category. I think of this metric as a &#x201C;MakesDensity&#x201D;, but this is something I&#x2019;m just doing here.</p>
<p>\[MakesDensity =   \frac{number \space of \space makes\space for\space category}{number\space of\space models\space for\space category}\]</p>
<p>Now I can answer my question. And it turns out that Toys and Games are by far the most popular models by this metric.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><iframe width="900" height="450" frameborder="0" scrolling="no" src="PieChart_Python_Pygal_Thingiverse_Proportion_Makes_vs_Things.html"></iframe><!--kg-card-end: html--><!--kg-card-begin: markdown--><p>The next way to measure whether an object has been printed is by looking at the number of times it has been downloaded. You need to download a file in order to print it. But I know many of us download files and end up not using them, so this is not a direct indicator. Besides, I could not find a way to gather the download information about the files on Thingiverse using their API or in any other way.</p>
<p>That leaves me with likes and comments as metrics for popularity. Doing a similar analysis as before, I divided the like count for each category, by the number of models to get a useful metric:</p>
<p>\[Like Density =   \frac{number \space of \space likes \space for\space category}{number\space of\space models\space for\space category}\]</p>
<p>When comparing this with the total number of likes, I get the results below:</p>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><iframe width="900" height="450" frameborder="0" scrolling="no" src="BarChart_Python_Plotly_Thingiverse_likes_vs_likes_density_3D_printing.html"></iframe><!--kg-card-end: html--><!--kg-card-begin: markdown--><p>As we saw before, most objects on the portal are in the &#x201C;household&#x201D; and &#x201C;3D-printing&#x201D; categories. For that reason, they have the largest number of likes. However,  &#x201C;Toys-and-games&#x201D; shows the highest density of likes by published files - more than double of the next highest one, &#x201C;models&#x201D;.</p>
<p>I&#x2019;m curious to know whether that is because there are relatively few &#x201C;toys-and-games&#x201D; models with an insane amount of likes, or just because the people really like them and there are genuinely more likes per model in that category.</p>
<p>To find out, I plotted the empirical Cumulative Density Function of the like count for each category.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2022/11/eCDF_Likes_by_3D_print_categories_Thingiverse_Python_Seaborn.jpeg" class="kg-image" alt="What do people like to 3D print?" loading="lazy" width="2000" height="1500" srcset="http://localhost:2368/content/images/size/w600/2022/11/eCDF_Likes_by_3D_print_categories_Thingiverse_Python_Seaborn.jpeg 600w, http://localhost:2368/content/images/size/w1000/2022/11/eCDF_Likes_by_3D_print_categories_Thingiverse_Python_Seaborn.jpeg 1000w, http://localhost:2368/content/images/size/w1600/2022/11/eCDF_Likes_by_3D_print_categories_Thingiverse_Python_Seaborn.jpeg 1600w, http://localhost:2368/content/images/2022/11/eCDF_Likes_by_3D_print_categories_Thingiverse_Python_Seaborn.jpeg 2400w" sizes="(min-width: 720px) 720px"></figure><!--kg-card-begin: markdown--><p>It turns out that Toys and Games are really a lot more popular than the other categories (at least on Thingiverse). Around 60% of the Toys and Games models on the platform have less than 100 likes. For the other categories, that number is above 80% in all cases. In other words, there is a 40% chance that a Toys and Games model has more than 100 likes, and for the other categories, there is only a maximum chance of 20% for the Models category.</p>
<p>But this analysis does not consider the time it takes for the models to receive those likes. To analyze that, I divided the like count for each model by the number of days that passed since the day they were published and created another eCDF plot. Please notice the much smaller scale on the X-axis.</p>
<p>More than 90% of the models of all categories have an average of less than 0.1 like per day - that is 1 like every 10 days, except for Toys and Makes, and Models.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2022/11/eCDF_Likes_by_3D_print_categories_Thingiverse_Python_Seaborn_time.jpeg" class="kg-image" alt="What do people like to 3D print?" loading="lazy" width="2000" height="1500" srcset="http://localhost:2368/content/images/size/w600/2022/11/eCDF_Likes_by_3D_print_categories_Thingiverse_Python_Seaborn_time.jpeg 600w, http://localhost:2368/content/images/size/w1000/2022/11/eCDF_Likes_by_3D_print_categories_Thingiverse_Python_Seaborn_time.jpeg 1000w, http://localhost:2368/content/images/size/w1600/2022/11/eCDF_Likes_by_3D_print_categories_Thingiverse_Python_Seaborn_time.jpeg 1600w, http://localhost:2368/content/images/2022/11/eCDF_Likes_by_3D_print_categories_Thingiverse_Python_Seaborn_time.jpeg 2400w" sizes="(min-width: 720px) 720px"></figure><p>I think these are pretty interesting insights. Compared to Yeggi&#x2019;s survey <a href="https://www.yeggi.com/int/infographics?igid=What-People-Search-2013">&#x201C;What people search&#x201D;</a> conducted in 2013, this information also includes more recent data. Unfortunately, I left out the tags of each model when collecting the data, mainly because they created some issues when parsing the server responses as a pandas data frames. I might run my script again to get more updated information (maybe at the end of the year) and do some analysis with the tags of the most popular models.</p><p>I hope you liked this one! In the next post, I will go through the code I used to make this analysis. So stay tuned if you&#x2019;d like to see that.</p><p>Have a great day!</p>]]></content:encoded></item><item><title><![CDATA[Replacing MATLAB with Python - Part 3: Histograms and more data-indexing]]></title><description><![CDATA[I am sharing how I used Python to complete the second part of an example task originally done with MATLAB. I learned more about slicing dataframes and making histograms with two different libraries]]></description><link>http://localhost:2368/replacing-matlab-with-python-part-3/</link><guid isPermaLink="false">6331dac3986cb807b0d32918</guid><category><![CDATA[Python]]></category><category><![CDATA[Data]]></category><category><![CDATA[Engineering]]></category><dc:creator><![CDATA[Luis Medina]]></dc:creator><pubDate>Mon, 26 Sep 2022 17:39:21 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1548081597-c3552b4e9853?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDE3fHxwYW5kYXxlbnwwfHx8fDE2NjQyMTM5Nzc&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1548081597-c3552b4e9853?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDE3fHxwYW5kYXxlbnwwfHx8fDE2NjQyMTM5Nzc&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Replacing MATLAB with Python - Part 3: Histograms and more data-indexing"><p></p><p>Getting used to doing engineering or scientific computations using Python can be tricky, especially if starting with a MATLAB background. Some things might seem actually easier to do once you understand how Python works, and some other things might seem like they require a lot of additional work to get the results you want, compared to MATLAB. That happened to me, particularly when creating figures and plotting data, I struggled to obtain the exact same look as my MATLAB figures.</p><p>Speaking of replicating what we do in MATLAB, this is what I&#x2019;m actually doing with this series of posts about <a href="https://makerluis.com/replacing-matlab-with-python-part-1/">Replacing MATLAB with Python</a>. The last few entries have been centered around an example task that <a href="https://makerluis.com/using-matlab-and-statistics-to-analyze-raw-vehicle-data">I first solved with MATLAB</a>, and now I am trying to do the same with Python instead. To keep this post short, I&#x2019;m saving you the explanation of the context and what we are trying to achieve since I&#x2019;ve already talked about it in the previous two posts.</p><p>I hope this kind of examples can be useful if you are also learning Python and trying to do similar things for school, work, or just hobby.</p><p>In the <a href="https://makerluis.com/replacing-matlab-with-python-part-2">previous post</a>, I completed the first part of the task, estimating the vehicle speeds and elapsed times of two drivers, using some raw data. We saw different examples of how to index (slice) pandas dataframes quickly to sort out our data. I also used both Pyplot and Plotly to create figures with subplots of time series. This time, I&#x2019;ll show you how I completed the second part of the task. This will be a useful exercise to practice making histograms. I will try again both libraries since they are very different and I want to learn both of them.</p><p>Let&apos;s begin!</p><h2 id="creating-histograms-with-pyplot">Creating histograms with Pyplot</h2><p>I want to compare how much time the drivers spent at different speeds. A common way to do this is by making a histogram of their speeds.</p><p>As with MATLAB, I learned two different ways to do this using the &#x201C;standard&#x201D; libraries for Python. In this case, I&apos;m calling Pyplot &#x201C;standard&#x201D; only because it is probably the first plotting library most people see and start using when coming from MATLAB. The syntax and logic are quite similar - it is part of <a href="https://matplotlib.org/">Matplotlib</a>.</p><p>I will start by creating a figure with two subplots, and will use each subplot to illustrate a different approach - this is just the same thing I did with MATLAB <a href="https://makerluis.com/using-matlab-and-statistics-to-analyze-raw-vehicle-data/index.html#comparing-the-speeds-of-both-drivers">here</a>, I want to highlight the parallelism.</p><pre><code class="language-python">fig, axs = plt.subplots(1,2, sharex=True, figsize = (3000/300, 1000/300), dpi = 300)
fig.suptitle(&apos;Different types of histogram using Pyplot (driver speed comparison)&apos;, fontweight=&apos;bold&apos;)

# Define common bins to use
histbins = np.linspace(0, 100, num=20, endpoint=True)

</code></pre><p>Now I will plot on the left side two histograms at once. To do this, I put the two dataframe columns in a list using <code>[&lt;data1&gt;, &lt;data2&gt;]</code> &#xA0;- &#xA0;remember from the previous posts that we have our data stored in two dataframes, <code>df1</code> and <code>df2</code>. Then knowing the order of my list, I can define the format consistently for each data series.</p><pre><code class="language-python"># Left side: Side-by-side bars, not normalized
axs[0].set_title(&apos;Side-by-side bars&apos;, loc = &apos;center&apos;)
axs[0].grid(alpha= 0.3)
axs[0].hist([df1[&apos;Vehicle Speed&apos;], df2[&apos;Vehicle Speed&apos;]], bins = histbins, 
                                                          density=False, 
                                                          histtype=&apos;bar&apos;, 
                                                          color=[&apos;blue&apos;, &apos;red&apos;], 
                                                          label=[&apos;Driver 1&apos;, &apos;Driver 2&apos;], 
                                                          edgecolor = &apos;black&apos;)
axs[0].set_ylabel(&apos;Counts&apos;)
axs[0].set_xlabel(&apos;Vehicle speed [km/h]&apos;)
axs[0].legend()
</code></pre><!--kg-card-begin: markdown--><p>Notice that these two histograms are not normalized (<code>density = False</code>) and the counts are represented using side-by-side bars.</p>
<!--kg-card-end: markdown--><p>Next, on the right side, I will create two overlapping histograms, this time normalized. Here it&#x2019;s especially important to use common bins, otherwise, the comparison will be skewed. This is why I defined <code>histbins</code> in advance. It is also a good practice to add some transparency using the <code>alpha</code> argument to be able to see the areas where they will overlap.</p><pre><code class="language-python"># Right side: Overlapping and normalized histograms
axs[1].set_title(&apos;Overlapping histograms&apos;, loc = &apos;center&apos;)
axs[1].grid(alpha= 0.3)
axs[1].hist(df1[&apos;Vehicle Speed&apos;], bins = histbins, density=True, 
                                  histtype=&apos;bar&apos;,  color=&apos;blue&apos;, 
                                  label=&apos;Driver 1&apos;, edgecolor = &apos;black&apos;, 
                                  alpha = 0.5)

axs[1].hist(df2[&apos;Vehicle Speed&apos;], bins = histbins, density=True, 
                                  histtype=&apos;bar&apos;,  color=&apos;red&apos;, 
                                  label=&apos;Driver 2&apos;, edgecolor = &apos;black&apos;, 
                                  alpha = 0.5)
axs[1].set_ylabel(&apos;Probability Density Function (PDF)&apos;)
axs[1].set_xlabel(&apos;Vehicle speed [km/h]&apos;)
axs[1].legend()
</code></pre><p>The result is very close to the MATLAB figure:</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2022/09/different_histograms_Pyplot.jpeg" class="kg-image" alt="Replacing MATLAB with Python - Part 3: Histograms and more data-indexing" loading="lazy" width="2000" height="671" srcset="http://localhost:2368/content/images/size/w600/2022/09/different_histograms_Pyplot.jpeg 600w, http://localhost:2368/content/images/size/w1000/2022/09/different_histograms_Pyplot.jpeg 1000w, http://localhost:2368/content/images/size/w1600/2022/09/different_histograms_Pyplot.jpeg 1600w, http://localhost:2368/content/images/size/w2400/2022/09/different_histograms_Pyplot.jpeg 2400w" sizes="(min-width: 720px) 720px"></figure><p>As we&#x2019;ve already discussed, the second driver was faster (spent more time at higher speeds).</p><p>The next thing we want to do is to figure out at what speeds were the two of them braking, i.e. at which vehicle speed they were starting to press the brake pedal at corner entries. This gives us a better idea of what is making them have such different speeds since both of them were using the exact same car (at different moments, of course).</p><h2 id="slicing-pandas-dataframes-to-identify-brake-pedal-pressings">Slicing Pandas dataframes to identify brake pedal pressings</h2><p>We need to find the speeds at the start of braking. With MATLAB, I first tried doing this with a for-loop (which took ages) and then showed how faster it was to use indexing operations instead. &#xA0;Here, I will jump straight to the indexing part.</p><p>As in the MATLAB example, I first defined a low threshold value of pressure to identify the start of pedal presses.</p><pre><code class="language-python">p_start = 2
</code></pre><p>Then, I want to find the rows that satisfy these three conditions:</p><ul><li>The current pressure is lower than the threshold</li><li>Pressure in the next instant is greater than the threshold</li><li>The vehicle is moving above a minimum speed</li></ul><p>To compare the two instants, I made copies of the columns containing the brake pressures and shifted them by one row upwards. This way I have both the current and the next pressure values in the same rows. Then I deleted the last row of each dataframe, since it would contain an empty value due to the column shift.</p><pre><code class="language-python">df1[&apos;BrakesShifted&apos;] = df1[&apos;BrakeFront&apos;].shift(-1)
df1 = df1[:-1]

df2[&apos;BrakesShifted&apos;] = df2[&apos;BrakeFront&apos;].shift(-1)
df2 = df2[:-1]
</code></pre><p>Maybe an unorthodox trick? I don&#x2019;t know, but it worked great. Having that, I just needed to use the &#xA0;<code>loc</code> method to slice the dataframes using the three conditions mentioned before, and store the results in a new pair of dataframes:</p><pre><code class="language-python">Brake_start1 = df1.loc[(df1.BrakeFront &lt;= p_start) &amp; 
                       (df1.BrakesShifted &gt; p_start) &amp; 
                       (df1[&apos;Vehicle Speed&apos;] &gt;= 15) ]

Brake_start2 = df2.loc[(df2.BrakeFront &lt;= p_start) &amp;
                       (df2.BrakesShifted &gt; p_start) &amp; 
                       (df2[&apos;Vehicle Speed&apos;] &gt;= 15) ] 
</code></pre><p>Next, I plotted the results to make sure they make sense. This time I will use Plotly to practice using a different library. The approach it uses is very different from Matplotlib. Just remember from the previous post that I imported the library and the methods for working with subplots using</p><pre><code class="language-python">import plotly.graph_objects as go
from plotly.subplots import make_subplots
</code></pre><p>The first thing to do having imported the library is to create a figure from the graphical objects library. I had to specify in advance that the figure will have secondary axes. To do this, I pass to the function <code>make_subplots</code> &#xA0;an argument consisting of a list of dictionaries (in this case just one, indicating that the secondary axis is enabled). How would I know that? Very simple, I learned it from the <a href="https://plotly.com/python/multiple-axes/">documentation</a>.</p><pre><code class="language-python">fig = make_subplots(specs=[[{&quot;secondary_y&quot;: True}]])
</code></pre><p>This created a figure, and now I can add traces for the vehicle speed and brake pressure. I want to overlap the two of them, using a common x-axis (time base). To do this, I added two independent traces, one for each variable, but the data for the x-axis is the same for both.</p><pre><code class="language-python"># Add line plots
fig.add_trace(
    go.Line(y=df1[&apos;Vehicle Speed&apos;] ,x=df1.Time_s,name = &apos;Vehicle Speed&apos;),
    secondary_y=False)
fig.update_yaxes(title_text=&quot;Speed [km/h]&quot;, range=[0, 80], secondary_y=False)

fig.add_trace(
    go.Line(y=df1[&apos;BrakeFront&apos;] ,x=df1.Time_s,name = &apos;Brakes Pressure&apos;),
    secondary_y=True)
fig.update_yaxes(title_text=&quot;Pressure [bar]&quot;, range=[0, 50], secondary_y=True, color = &apos;red&apos;)
</code></pre><p>Notice that I specified the option <code>secondary_y=True</code> for the second set of data (in this case the pressure). In MATLAB, I would have issued a <code>yyaxis right</code> command just before creating the second line plot. The procedure here is simply different.</p><p>Next, I wanted to add vertical lines to indicate the instants that I identified as starts of braking maneuvers. If the pressure was rising suddenly starting from those points, and the vehicle speed was plausible for a braking maneuver, then the identified points make sense.</p><p>To make the lines, I had to resort to a for-loop this time:</p><pre><code class="language-python">for time in Brake_start1.Time_s:
    fig.add_shape(go.layout.Shape(type = &quot;line&quot;,
                                    yref = &quot;y&quot;, xref = &quot;x&quot;,
                                    x0 = time, y0=0,
                                    x1 = time, y1 = 100))
</code></pre><p>Shame on me for not having a better method. This won&#x2019;t let me sleep at night until I figure out how to do it more efficiently. Or maybe not, we&#x2019;ll see.</p><p>To finish, I added some formatting with the following code:</p><pre><code class="language-python">fig.update_xaxes(title_text=&quot;Time [s]&quot;, range = [700, 750] )
fig.update_layout(title = {
                            &apos;text&apos;: &apos;&lt;b&gt;Identified starts of braking maneuvers&lt;/b&gt;&apos;, 
                            &apos;xanchor&apos; : &apos;center&apos;,
                            &apos;x&apos; : 0.5, &apos;y&apos;: .95, &apos;font_size&apos; : 12
                            },
                showlegend=False)

fig
</code></pre><p>The result looks quite good! And the interactive plot can be used in websites, like this one &#x1F603;</p><!--kg-card-begin: html--><iframe width="900" height="450" frameborder="0" scrolling="no" src="Braking_Starts_Plotly.html"></iframe><!--kg-card-end: html--><p></p><p>To obtain this interactive HTML file, I used:</p><pre><code class="language-python">filename = example
fig.write_html(f&apos;{filename}.html&apos;)
</code></pre><p>Which saved an HTML file in my local directory. I then hosted it on GitHub to share it with you guys on this post.</p><h2 id="creating-histograms-with-plotly">Creating histograms with Plotly</h2><p>OK! the points identified as starts of braking maneuvers make sense. Now it&#x2019;s time to use Plotly to make some histograms.</p><p>I created a figure and defined the common bins to use. Notice that the bins are defined using a dictionary:</p><pre><code class="language-python">#Create figure
fig = go.Figure()

#Define common bins
bins = dict(start= 10,
            end=  100,
            size= 5)
</code></pre><p>Then, I added the traces and formatted the figure:</p><pre><code class="language-python">fig.add_trace(go.Histogram(x=Brake_start1[&apos;Vehicle Speed&apos;],
                           xbins = bins, 
                           histnorm=&apos;probability density&apos;, 
                           opacity=0.9,
                           name = &apos;Driver 1&apos;))

fig.add_trace(go.Histogram(x=Brake_start2[&apos;Vehicle Speed&apos;],
                           xbins = bins, 
                           histnorm=&apos;probability density&apos;,
                           opacity=0.7,
                           name = &apos;Driver 2&apos;))                            

fig.update_layout(
    title_text=&apos;&lt;b&gt;Vehicle speeds at the start of braking&lt;/b&gt;&apos;, 
    xaxis_title_text=&apos;Vehicle speed [km/h]&apos;, 
    yaxis_title_text=&apos;Probability Density&apos;, 
    bargap=0.2,)

fig.show()
</code></pre><!--kg-card-begin: html--><iframe width="900" height="450" frameborder="0" scrolling="no" src="Histogram_Braking_Starts_Plotly.html"></iframe><!--kg-card-end: html--><p>The histograms don&#x2019;t lie! Again, but this time with Python, we can see that the first driver was braking earlier than the second one. Although they both reached speeds of 80 km/h, it seems that the first driver never made a braking maneuver above 75 km/h. Instead, driver 1 made a significantly greater number of braking maneuvers between 65 and 70 km/h - the peak for driver 2 is around 75 - 80 km/h instead.</p><h2 id="conclusion">Conclusion</h2><p>Just like that, we have completed the last part of the original post I wrote about <a href="https://makerluis.com/using-matlab-and-statistics-to-analyze-raw-vehicle-data/index.html">doing this with MATLAB</a>. This was a very simplified or superficial analysis, but I think it was a great toy example for me to practice and learn more Python with some specific tasks. I had to filter data, index dataframes, plot time-series data and create different types of histograms. I even used figures with subplots and secondary axes.</p><!--kg-card-begin: html--><div style="width:100%;height:0;padding-bottom:77%;position:relative;"><iframe src="https://giphy.com/embed/uCZPNoeoaLjt6" width="100%" height="100%" style="position:absolute" frameborder="0" class="giphy-embed" allowfullscreen></iframe></div><p><a href="https://giphy.com/gifs/community-nice-great-uCZPNoeoaLjt6">via GIPHY</a></p><!--kg-card-end: html--><p>I&#x2019;m starting to embrace the fact that Python is meant to be used in a different way, and things are actually easier now that I focus on learning how to use the language to complete a task, rather than replicating exactly what I did using MATLAB, especially when it comes to plotting data. If I get the same look, then it&#x2019;s fine. If I don&#x2019;t, but the results are decent, I don&#x2019;t stress too much about formatting - unless it is strictly required.</p><p>I really enjoyed making this series of posts, and I hope you have found some useful things here. Anyways, the Replacing MATLAB with Python series does not finish here, I am just making some space for other articles I have prepared, and will certainly add other posts for this series in the future. Perhaps more related to the original subject of this blog, which is actually making stuff. We&#x2019;ll see.</p><p>Thank you for reading this and stay tuned for the next one!</p><p>Cheers!</p><h3 id="the-pythonic-way-of-doing-things">The Pythonic way of doing things</h3><p>One of the most popular things about Python is its readability. When the language is being used properly, the code is more efficient, and it almost reads like plain English. The best way to achieve this is to follow a set of guidelines for coding style, which are known as the <a href="https://docs.python-guide.org/writing/style/">&#x201C;Pythonic&#x201D;</a> way. I will try to learn this and apply it to my code as I go. I think it makes you think more in terms of code efficiency and make better use of the language.</p>]]></content:encoded></item><item><title><![CDATA[Replacing MATLAB with Python - Part 2: Formatting subplots and indexing data]]></title><description><![CDATA[I used Python to complete the first part of the task from my previous post in the series. I learned about formatting plots and indexing Pandas dataframes.]]></description><link>http://localhost:2368/replacing-matlab-with-python-part-2/</link><guid isPermaLink="false">631c1b82d1122d218c763cb1</guid><category><![CDATA[Python]]></category><category><![CDATA[MATLAB]]></category><category><![CDATA[Data]]></category><category><![CDATA[Engineering]]></category><category><![CDATA[SignalProcessing]]></category><dc:creator><![CDATA[Luis Medina]]></dc:creator><pubDate>Mon, 19 Sep 2022 05:18:44 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1551431524-06b3c82d31ca?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDk3fHxrZXlib2FyZHxlbnwwfHx8fDE2NjM1NjQ5NDc&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1551431524-06b3c82d31ca?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDk3fHxrZXlib2FyZHxlbnwwfHx8fDE2NjM1NjQ5NDc&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Replacing MATLAB with Python - Part 2: Formatting subplots and indexing data"><p>A couple of weeks ago, I published the second entry of the <strong><a href="https://makerluis.com/replacing-matlab-with-python-part-1/index.html">Replacing MATLAB with Python</a></strong> series I started in August. I am sharing examples of how to do that, with some comments about the problems I find while learning Python.</p><p>In the <a href="https://makerluis.com/using-matlab-and-statistics-to-analyze-raw-vehicle-data/index.html">previous post</a> of the series, I didn&#x2019;t really share any Python code, though. It was an example of how I would use MATLAB to get information from raw data collected from a race car&#x2019;s CAN bus.</p><p>In this entry, &#xA0;I&#x2019;m using Python to do the first part of the task: visualize the signals we have by creating a figure with subplots, filter the raw acceleration data, compute the vehicle speed for the two drivers, and compare it. It took me more than twice the time to do it in Python than it did with MATLAB. That&#x2019;s mainly because I have been using MATLAB for many years now, and I am just getting used to Python. Especially when formatting plots, there are several things to handle differently from Matlab, &#xA0;or even from one Python library to another.</p><p>As always, bear in mind that this is not intended to be a Python course, but rather a series of practical examples.</p><p>Alright, to the code!</p><hr><h2 id="importing-the-data">Importing the data</h2><p>I&#x2019;m following the same workflow that I used for the <a href="https://makerluis.com/using-matlab-and-statistics-to-analyze-raw-vehicle-data/index.html">MATLAB version of this</a>, where I also provided more context on what we have. Short story, we want to compare the performance of two drivers, and we have the car data for each one in separate CSV files.</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://drive.google.com/drive/folders/16f2fLXelTBtj9vFxSSiNUQrmIUy3IEPX?usp=sharing"><div class="kg-bookmark-content"><div class="kg-bookmark-title">RaceCar data - Google Drive</div><div class="kg-bookmark-description"></div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://ssl.gstatic.com/docs/doclist/images/drive_2022q3_32dp.png" alt="Replacing MATLAB with Python - Part 2: Formatting subplots and indexing data"><span class="kg-bookmark-author">Google Drive</span></div></div><div class="kg-bookmark-thumbnail"><img src="https://drive-thirdparty.googleusercontent.com/128/type/text/csv" alt="Replacing MATLAB with Python - Part 2: Formatting subplots and indexing data"></div></a></figure><p>This is the code I wrote to start with. We&#x2019;ve already seen how to load information from CSV files and use <a href="https://pandas.pydata.org/">Pandas</a> to handle our data.</p><p>When using Python, the first thing we do is import the libraries we are going to use. We don&#x2019;t necessarily have to put the imports on top of everything, but it&#x2019;s in general good practice.</p><p></p><pre><code class="language-python">#%% Import libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

#%% Load data from CSV files

df1 = pd.read_csv(&apos;driver1.csv&apos;)
print(df1.columns)

df2 = pd.read_csv(&apos;driver2.csv&apos;)
print(df2.columns)

#%% Define constants
gear_ratio = 16     # Transmission gear ratio
r = 0.263           # Wheel radius [m]

&gt;&gt; Index([&apos;Time_s&apos;, &apos;BrakeFront&apos;, &apos;AccX&apos;, &apos;spd_rpmFL&apos;, &apos;spd_rpmFR&apos;, &apos;spd_rpmRL&apos;,
       &apos;spd_rpmRR&apos;],
        dtype=&apos;object&apos;)
</code></pre><p>All good! We have a unique time base and 6 signals in each file. But we have to make sure they are consistent and can be used together. This is why the next thing I did in MATLAB was plotting the variables. </p><p>When I tried to do the same thing using Python, it took me a while. More than I am comfortable admitting. I was stubbornly trying to get the exact same look I got with the default settings in MATLAB and, obviously, that required a lot of formatting. At some point I got it, but the number of trials with format options was just not worth it. Just look at the <code>plt.rcParams.update</code> call at the bottom of the next code snippet! My advice: if you are replacing MATLAB with Python, don&#x2019;t try to get exactly the same look on your charts unless there is a real need for that- in my case, there wasn&#x2019;t.</p><p></p><pre><code class="language-python"># If needed, reset plot parameters from any previous plot
# plt.rcParams.update(plt.rcParamsDefault)

fig = plt.figure(figsize = (1200/300, 600/300), dpi = 300)

c = 1 # subplot counter
for col in df1.columns[1:]:
    ax = plt.subplot(3, 3, c)
    ax.plot(df1[&apos;Time_s&apos;], df1[col], label = &apos;1&apos;, linewidth = 0.2)
    ax.plot(df2[&apos;Time_s&apos;], df2[col], label = &apos;2&apos;, linewidth = 0.2)
    leg = ax.legend(edgecolor = &apos;black&apos;,
                    borderpad=.5, borderaxespad = .5,
                    fontsize = 3, fancybox = False,
                    loc = &apos;upper right&apos;)
    plt.xlabel(&apos;Time [s]&apos;, fontsize = 3.5)
    plt.title( col, fontweight=&quot;bold&quot;, y = 1.05, fontsize = 3.5)
    leg.get_frame().set_linewidth(.1)    
    c = c + 1

plt.rcParams.update({&apos;axes.grid&apos;: False,
                    &apos;xtick.labelsize&apos;: 3,
                    &apos;ytick.labelsize&apos;: 3,
                    &apos;axes.labelpad&apos;: 1.0,
                    &apos;axes.labelsize&apos;: 3.5,
                    &apos;axes.linewidth&apos;: 0.5,
                    &apos;ytick.major.pad&apos;: 1,
                    &apos;ytick.minor.left&apos;: False,
                    &apos;xtick.minor.bottom&apos;: False,
                    &apos;ytick.major.size&apos;: 1,
                    &apos;ytick.major.width&apos;: .2,
                    &apos;xtick.major.pad&apos;: 1,
                    &apos;xtick.major.size&apos;: 1,
                    &apos;xtick.major.width&apos;: .2})

fig.tight_layout()

fig.subplots_adjust(
    top=0.92,
    bottom=0.1,
    left=0.05,
    right=0.98,
    hspace=0.6,
    wspace=0.2
)

fig
</code></pre><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2022/09/data_subplots_Python_Pyplot.jpeg" class="kg-image" alt="Replacing MATLAB with Python - Part 2: Formatting subplots and indexing data" loading="lazy" width="2000" height="693" srcset="http://localhost:2368/content/images/size/w600/2022/09/data_subplots_Python_Pyplot.jpeg 600w, http://localhost:2368/content/images/size/w1000/2022/09/data_subplots_Python_Pyplot.jpeg 1000w, http://localhost:2368/content/images/size/w1600/2022/09/data_subplots_Python_Pyplot.jpeg 1600w, http://localhost:2368/content/images/size/w2400/2022/09/data_subplots_Python_Pyplot.jpeg 2400w" sizes="(min-width: 720px) 720px"><figcaption>Plot of the time-series data stored in the CSV files. I didn&#x2019;t manage to get the exact look of the MATLAB plot. But that&#x2019;s OK!</figcaption></figure><p>Some of the useful resources I found online to learn about formatting are: first of all, Matplotlib&apos;s official <a href="https://matplotlib.org/stable/tutorials/introductory/customizing.html">documentation</a>. Second, the countless number of sites with Python tutorials online - just googled my questions and found good answers in the first page of results. Third, previously-answered questions on <a href="https://stackoverflow.com/">stackoverflow</a>.</p><hr><p>Something nice about Python is that we are able to iterate directly through the columns of our dataframe, instead of creating an index and then slicing the dataframe by column position. By doing it this way, I just needed to make a counter to move to the next plot, and the data was selected from the current column. The results are not identical to the ones I got in MATLAB, but that&#x2019;s OK.</p><p>All this additional formatting is needed only if you are using the relatively low-level library <a href="https://matplotlib.org/stable/tutorials/introductory/pyplot.html#">Pyplot</a> and you want to get some really specific format. If you loosen the format a bit and open up to other options - like <a href="https://seaborn.pydata.org/">Seaborn</a> for example - you can actually get away with very little code to get some impressive plots. Or, if you need to make interactive plots, you could use <a href="https://plotly.com/graphing-libraries/">Plotly</a>, like I did when visualizing <a href="https://makerluis.com/that-s-it-i-am-getting-a-more-reliable-3d-printer/index.html">how warped the bed of my 3D printer was</a>. I&#x2019;ll show another example next, when we compare the speeds of the two drivers.</p><p>Fine, we can make plots without stressing too much about the format and live with it.</p><p>Let&#x2019;s move on.</p><h2 id="filtering-acceleration-data">Filtering acceleration data</h2><p>As in the MATLAB example, I used a digital filter to smooth the acceleration signals. I&#x2019;m filtering only those because they are the only ones containing raw data from sensors. Here&#x2019;s what the raw acceleration data looks like when compared against the filtered one:</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2022/09/raw_vs_filtered_acc.jpeg" class="kg-image" alt="Replacing MATLAB with Python - Part 2: Formatting subplots and indexing data" loading="lazy" width="1200" height="400" srcset="http://localhost:2368/content/images/size/w600/2022/09/raw_vs_filtered_acc.jpeg 600w, http://localhost:2368/content/images/size/w1000/2022/09/raw_vs_filtered_acc.jpeg 1000w, http://localhost:2368/content/images/2022/09/raw_vs_filtered_acc.jpeg 1200w" sizes="(min-width: 720px) 720px"></figure><p></p><p>The code I used for doing this is quite simple.</p><!--kg-card-begin: markdown--><p>First, I computed the sum of the speeds of the four in-wheel motors. To do this, I needed to select only the columns for those variables, and compute the sum for each row. In MATLAB we can select data from tables using numerical indeces and round parenthesis directly, and the result is a table object. With Python, to index a dataframe this way, we need to use the <code>iloc</code> method. This allows you to slice the dataframe using numerical indices. In this case I selected all the rows, and then the columns from the third one till the end, so the returned object is also a dataframe.</p>
<p>To compute the sum of each row, I used the <code>sum</code> method of dataframes, passing as argument <code>axis = 1</code> to indicate that I want to sum each row and put the results in a column. For dataframes, rows are axis 0 and columns are axis 1. This is equivalent to MATLAB&apos;s concept of rows and columns in tables. So when I sum along axis 1, I add all the column values on each row.</p>
<p>The results are stored in new columns named &apos;SumSpeeds&apos; in the original dataframes.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-code-card"><pre><code class="language-python">df1[&apos;SumSpeeds&apos;] = df1.iloc[:,3:].sum(axis=1)
df2[&apos;SumSpeeds&apos;] = df2.iloc[:,3:].sum(axis=1)</code></pre><figcaption>Computing the sum of the motor speeds</figcaption></figure><p>Cool! Next, I removed the DC offsets from the acceleration signals. I selected only the rows in which the sum of the speeds was zero and computed the median of the acceleration values. Then I subtracted this non-zero offset from the acceleration signals. This is how I did that:</p><figure class="kg-card kg-code-card"><pre><code class="language-python">df1[&apos;AccX_NoOffs&apos;] = df1[&apos;AccX&apos;] - df1[df1[&apos;SumSpeeds&apos;] == 0][&apos;AccX&apos;].median()
df2[&apos;AccX_NoOffs&apos;] = df2[&apos;AccX&apos;] - df2[df2[&apos;SumSpeeds&apos;] == 0][&apos;AccX&apos;].median()</code></pre><figcaption>Remove the DC offset from the raw acceleration signals</figcaption></figure><!--kg-card-begin: markdown--><p>In this case I sliced the dataframe using a different approach. I compared the &apos;SumSpeeds&apos; column with zero, creating a series object with logical statements (True/False). This is equivalent to doing <code>myseries = df_A[&apos;SumSpeeds&apos;] == 0</code>. Then, I sliced the original dataframes using that series as index. This returned a new dataframe containing all the rows in which the condition is met, and all the columns, as in <code>df_B = df_A[myseries]</code>. Finally, I selected the &apos;AccX&apos; column from the resulting dataframe and computed the median from it. It would have looked like <code>DC_offset = df_B[&apos;AccX&apos;].median()</code>. And this is what I subtracted from the original signals.</p>
<!--kg-card-end: markdown--><p>The last part was filtering the corrected signals and finally making the figure I previously showed, comparing the raw and filtered signals:</p><figure class="kg-card kg-code-card"><pre><code class="language-python">from scipy.signal import savgol_filter

df1.AccX = savgol_filter(df1.AccX_NoOffs, 101, 3)
df2.AccX = savgol_filter(df2.AccX_NoOffs, 101, 3)

# reset figure parameters if previously changed
#plt.rcParams.update(plt.rcParamsDefault) 

# Compare raw acceleration vs filtered
fig = plt.figure(figsize = (1200/300, 400/300), dpi=300)
plt.plot(df1.Time_s, df1.AccX_NoOffs, label = &apos;Raw (removed DC offset)&apos;, linewidth = .5)
plt.plot(df1.Time_s, df1.AccX, label = &apos;Filtered&apos;, linewidth = 1)
plt.xlabel(&apos;Time [s]&apos;)
plt.ylabel(&quot;Acceleration [G-units]&quot;)
plt.xlim(600, 650)

leg = plt.legend(fancybox = False, 
                edgecolor = &apos;inherit&apos;, fontsize = 4,
                loc = &apos;upper right&apos;)


plt.title(&apos;Raw vs Filtered Longitudinal Acceleration&apos;)

plt.rcParams.update({&apos;font.size&apos;: 5,
                    &apos;axes.grid&apos;: True,
                    &apos;axes.grid.which&apos;: &apos;both&apos;,
                    &apos;xtick.minor.visible&apos;: True,
                    &apos;ytick.minor.visible&apos;: True,
                    &apos;grid.linewidth&apos;: 0.2,
                    &apos;lines.linewidth&apos;: 0.2})


# Display figure
plt.tight_layout()
fig</code></pre><figcaption>Filtering acceleration data once the DC offsets have been removed</figcaption></figure><p>I implemented the same type of filter I used in MATLAB, I just needed an additional library import. However, &#xA0;the input arguments for the Python version <code>savgol_filter(data_array, window_size, poly_order)</code> are swapped with respect to MATLAB&#x2019;s (recall I used <code>sgolayfilt(data_array, poly_order, window_size)</code> &#xA0;in the previous post). We can spot this kind of thing by looking at the documentation. Always read the documentation! With Python, you can access it quickly by typing <code>print(&lt;library,object or function&gt;.__doc___)</code> or simply <code>help(&lt;library,object or function&gt;)</code> .</p><p>Unfortunately, the official documentation for many Python functions is not as detailed as the MATLAB counterpart. For instance, compare the <a href="https://it.mathworks.com/help/signal/ref/sgolayfilt.html">MATLAB</a> and <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.savgol_filter.html">Python (Scypi)</a> official documentation for the filter we used. The former is much clearer. This can be a big thing for many people wanting to learn Python coming from MATLAB, but there is a way to go around it! There are a lot more tutorials online about Python than there are for MATLAB. You just have to embrace the power of <strong>googling</strong>, and lose the fear of sites like <a href="https://stackoverflow.com/">stackoverflow</a>. For example, I found <a href="https://nirpyresearch.com/savitzky-golay-smoothing-method/">this great article</a> about the filter we are using. Additionally, the best thing to do is check some <a href="https://www.ece.rutgers.edu/~orfanidi/intro2sp/">Signal Processing book</a> to learn more about digital filters.</p><p>Ok! I am deviating from the point of this article. Going back to the code examples.</p><h2 id="finding-the-vehicle-speed-indexing-dataframes">Finding the vehicle speed: indexing dataframes</h2><p>As I <a href="https://makerluis.com/using-matlab-and-statistics-to-analyze-raw-vehicle-data/index.html#estimating-the-vehicle-speeds">mentioned</a> in the MATLAB example, we can estimate the vehicle speed using the information from the speeds of the four in-wheel motors. We just need to treat differently the cases in which the vehicle was accelerating and those in which it was braking. To do this, we&apos;ll need to index (slice) the dataframe based in conditions similar to what I did with the raw acceleration data when computing the DC offset. See how I did it in the code below:</p><p></p><pre><code class="language-python">import timeit

%%timeit

df1[&apos;Vehicle Speed&apos;] = 0
df2[&apos;Vehicle Speed&apos;] = 0

# Estimated vehicle speeds when braking (AccX &lt; = 0)
df1.loc[df1[&apos;AccX&apos;] &lt;= 0, &apos;Vehicle Speed&apos;] =  df1.loc[df1[&apos;AccX&apos;] &lt;= 0,
                                            (&apos;spd_rpmFL&apos;,&apos;spd_rpmFR&apos;,&apos;spd_rpmRL&apos;,&apos;spd_rpmRR&apos;)].max(axis=1)*np.pi/30*r/gear_ratio*3.6
df2.loc[df2[&apos;AccX&apos;] &lt;= 0, &apos;Vehicle Speed&apos;] =  df2.loc[df2[&apos;AccX&apos;] &lt;= 0,
                                            (&apos;spd_rpmFL&apos;,&apos;spd_rpmFR&apos;,&apos;spd_rpmRL&apos;,&apos;spd_rpmRR&apos;)].max(axis=1)*np.pi/30*r/gear_ratio*3.6

# Estimated vehicle speeds when accelerating (AccX &gt; 0)
df1.loc[df1[&apos;AccX&apos;] &gt; 0, &apos;Vehicle Speed&apos;] =  df1.loc[df1[&apos;AccX&apos;] &gt; 0,
                                            (&apos;spd_rpmFL&apos;,&apos;spd_rpmFR&apos;,&apos;spd_rpmRL&apos;,&apos;spd_rpmRR&apos;)].min(axis=1)*np.pi/30*r/gear_ratio*3.6
df2.loc[df2[&apos;AccX&apos;] &gt; 0, &apos;Vehicle Speed&apos;] =  df2.loc[df2[&apos;AccX&apos;] &gt; 0,
                                            (&apos;spd_rpmFL&apos;,&apos;spd_rpmFR&apos;,&apos;spd_rpmRL&apos;,&apos;spd_rpmRR&apos;)].min(axis=1)*np.pi/30*r/gear_ratio*3.6
                                            
# Output 62.2 ms &#xB1; 3.78 ms per loop (mean &#xB1; std. dev. of 7 runs, 10 loops each)
</code></pre><p>That was very quick. As you can see, if you get used to indexing MATLAB tables, the switch to Pandas dataframes is a lot easier. The syntax (or rather, the logic) is very similar - though it is not exactly the same.</p><p>Now, we can just compare the speeds. First, I computed the start and end times for both drivers. This is not precise, I just defined a speed threshold of 20 km/h and found the instants when the car was slower and faster than that. Again, dataframe slicing is very helpful for this:</p><pre><code class="language-python"># Find index of first instant at which speed is greater than 20 km/h
index_start1 = df1[df1[&apos;Vehicle Speed&apos;]&gt;20].index[0]
index_start2 = df2[df2[&apos;Vehicle Speed&apos;]&gt;20].index[0]
time_start1 = df1[&apos;Time_s&apos;][index_start1]
time_start2 = df2[&apos;Time_s&apos;][index_start2]

# Find index of last instant at which speed is greater than 20 km/h
index_end1 = df1[df1[&apos;Vehicle Speed&apos;]&gt;20].index[-1]
index_end2 = df2[df2[&apos;Vehicle Speed&apos;]&gt;20].index[-1]
time_end1 = df1[&apos;Time_s&apos;][index_end1]
time_end2 = df2[&apos;Time_s&apos;][index_end2]

# Compute elapsed times
t_elap_1 = time_end1 - time_start1
t_elap_2 = time_end2 - time_start2
</code></pre><p>Next, I made a comparative plot (subplots again). &#xA0;This time with a different approach, though:</p><p></p><pre><code class="language-python"># %% Compare the speeds of the two drivers
from plotly.subplots import make_subplots
import plotly.graph_objects as go


# Create figure with subplots and add titles
fig = make_subplots(
    rows=2,
    cols=1,
    shared_xaxes=True,
    shared_yaxes=False,
    subplot_titles=((f&quot;Driver 1 approximate time : {t_elap_1:.1f} seconds&lt;br&gt;&quot; 
                     f&quot;Max. speed: {df1[&apos;Vehicle Speed&apos;].max():.1f} km/h, &quot;
                     f&quot;mean speed: {df1[&apos;Vehicle Speed&apos;].mean():.1f} km/h&quot;), 
                    (f&quot;Driver 2 approximate time : {t_elap_2:.1f} seconds&lt;br&gt;&quot;
                    f&quot;Max. Speed: {df2[&apos;Vehicle Speed&apos;].max():.1f} km/h, &quot;
                    f&quot;mean speed: {df2[&apos;Vehicle Speed&apos;].mean():.1f} km/h&quot;)
))

# Plot data for the first driver
fig.add_trace(
    go.Line(y=df1[&apos;Vehicle Speed&apos;] ,x=df1.Time_s,name = &apos;Driver 1&apos;),
    row = 1, col = 1)
# Add vertical lines to mark start and end points
for time in [time_start1, time_end1]:
    fig.add_shape(go.layout.Shape(type = &quot;line&quot;,
                                    yref = &quot;y&quot;, xref = &quot;x&quot;,
                                    x0 = time, y0=0,
                                    x1 = time, y1 = 100),
                                    row=1, col=1)
fig.update_yaxes(title_text=&quot;Speed [km/h]&quot;, range=[0, 100], row=1, col=1)

# Plot data for the second driver    
fig.add_trace(
    go.Line(y=df2[&apos;Vehicle Speed&apos;] ,x=df1.Time_s,name = &apos;Driver 2&apos;),
    row = 2, col = 1)
# Add vertical lines to mark start and end points
for time in [time_start2, time_end2]:
    fig.add_shape(go.layout.Shape(type = &quot;line&quot;,
                                    yref = &quot;y&quot;, xref = &quot;x&quot;,
                                    x0 = time, y0=0,
                                    x1 = time, y1 = 100),
                                    row=2, col=1)
fig.update_yaxes(title_text=&quot;Speed [km/h]&quot;, range=[0, 100], row=2, col=1)

fig.update_layout(title = {
                            &apos;text&apos;: &apos;&lt;b&gt;Driver time comparison&lt;/b&gt;&apos;, 
                            &apos;xanchor&apos; : &apos;center&apos;,
                            &apos;x&apos; : 0.5, &apos;y&apos;: .95, &apos;font_size&apos; : 20
                            },
                showlegend=False)

fig
</code></pre><p>Notice that I used Plotly instead of Pyplot. Confusing names, right? Pyplot is the &#x201C;vanilla&#x201D; one that comes with Matplotlib. It is easier to learn when starting with Python from a Matlab background and is used a lot for scientific and engineering publication-grade figures. But Plotly offers the possibility to make interactive plots with a little coding, which is awesome. Just look at the results:</p><!--kg-card-begin: html--><iframe width="900" height="450" frameborder="0" scrolling="no" src="Driver_time_Plotly.html"></iframe><!--kg-card-end: html--><hr><h3 id="wrapping-up">Wrapping up</h3><p>We completed the first part of the task, obtaining the same results as the Matlab example - fortunately! otherwise, there would be a great error somewhere.</p><p>When writing this, I think I spent 80% of my time figuring out how to make the plots look like I wanted. The rest was not really that hard. This is not surprising, since Python has gained popularity precisely for being easy to learn. It is easy, as long as you use it as it is intended to. The best way to achieve this is to follow a set of guidelines for coding style, which are known as the <a href="https://docs.python-guide.org/writing/style/" rel="noopener noreferrer">&#x201C;Pythonic&#x201D;</a> way. I will try to learn this and apply it to my code as I go. I think it makes you think more in terms of code efficiency and make better use of the language.</p><p>I hope these code examples were useful for you. In the next post, I will complete the second part of the task, using histograms and statistics to analyze the vehicle speeds and the braking performance of the two drivers. </p><p>In the meantime, I hope you have a wonderful day!</p>]]></content:encoded></item><item><title><![CDATA[Using MATLAB and statistics to analyze raw vehicle data]]></title><description><![CDATA[I am sharing an example of the workflow I would follow for getting insights from real-world data using histograms and some very basic statistics.]]></description><link>http://localhost:2368/using-matlab-and-statistics-to-analyze-raw-vehicle-data/</link><guid isPermaLink="false">6307015cdab1415e3c83e90f</guid><category><![CDATA[MATLAB]]></category><category><![CDATA[Engineering]]></category><category><![CDATA[Data]]></category><category><![CDATA[SignalProcessing]]></category><dc:creator><![CDATA[Luis Medina]]></dc:creator><pubDate>Sun, 04 Sep 2022 15:23:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1512717919743-801d3d85ec83?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDEwOHx8Y2FyJTIwdG95fGVufDB8fHx8MTY2MjMwMTQxMw&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1512717919743-801d3d85ec83?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDEwOHx8Y2FyJTIwdG95fGVufDB8fHx8MTY2MjMwMTQxMw&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Using MATLAB and statistics to analyze raw vehicle data"><p>It&#x2019;s been a couple of weeks since I published the <a href="https://makerluis.com/replacing-matlab-with-python-part-1/index.html">initial post</a> of a series about replacing MATLAB with Python. If you haven&#x2019;t read it yet, the short story is that I forced myself to use Python to do some of the tasks I would normally do using MATLAB at work. I committed to sharing what I&apos;ve learned in the process, including simple code examples to illustrate it, which may be useful if you are interested in doing something similar. I&apos;m no expert, though, so don&apos;t expect to see super complex codes or analyses here!</p><p>However, I figured that it would be easier to share separately the MATLAB examples and the Python ones. Mainly because, otherwise, the articles would be excessively long.</p><p>In this second entry, I am sharing an example of the workflow I would follow for getting insights from real-world data using histograms and some very basic statistics.</p><p>We will be using two datasets containing raw data logged from the CAN bus of a <a href="https://www.imeche.org/events/formula-student">Formula Student Electric</a> car. The data is already stored in a .CSV format to make this more &#x201C;universal&#x201D;, since there are different formats for storing automotive data.</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://drive.google.com/drive/folders/16f2fLXelTBtj9vFxSSiNUQrmIUy3IEPX?usp=sharing"><div class="kg-bookmark-content"><div class="kg-bookmark-title">RaceCar data - Google Drive</div><div class="kg-bookmark-description"></div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://ssl.gstatic.com/docs/doclist/images/drive_2022q3_32dp.png" alt="Using MATLAB and statistics to analyze raw vehicle data"><span class="kg-bookmark-author">Google Drive</span></div></div><div class="kg-bookmark-thumbnail"><img src="https://drive-thirdparty.googleusercontent.com/128/type/text/csv" alt="Using MATLAB and statistics to analyze raw vehicle data"></div></a></figure><p>For context, the datasets were recorded while two drivers tested exactly the same vehicle in exactly the same circuit. On the same day, a few minutes apart from each other. There was no transponder installed for recording the lap time accurately, and the information from the electric motors is not available for some reason. This is about all the context we need. We want to analyze the data from both drivers but won&#x2019;t go into the details. </p><hr><h3 id="let%E2%80%99s-jump-right-into-it">Let&#x2019;s jump right into it!</h3><p>When using MATLAB, I load the data from the CSV files, store the data in some variables, and define the constants that I am going to use later.</p><pre><code class="language-matlab">%% Get descriptive statistics from CAN datalogs
close all, clc

filename1 = &apos;driver1.csv&apos;;
filename2 = &apos;driver2.csv&apos;;

% Read file 1
t1 = readtable(filename1);
% Verify that I get all the columns I need
t1.Properties.VariableNames

% Repeat for file 2
t2 = readtable(filename2);
t2.Properties.VariableNames

%% Define vehicle parameters
% This was a Formula Student Electric car, with four in-wheel electric
% motors coupled to an epicyclic transmission, all four with the same gear ratio
gear_ratio = 16;    % Transmission gear ratio
r = 0.263;          % Wheel radius [m]</code></pre><p>I&apos;m using tables to handle the data because I find them very easy to use. Additionally, using tables in MATLAB can help you transition more easily to using Pandas data frames if you want to. This will be more evident later on. Tables are not the most efficient way to handle very large datasets, but they do offer some convenience and if you know how to index them, they work great.</p><p>Let&#x2019;s move on. I have the data loaded on MATLAB, so now I can do stuff. As I&#x2019;ve <a href="https://makerluis.com/replacing-matlab-with-python-part-1/index.html#example-1-simple-time-series-visualization">mentioned before</a>, a good practice is to start with a simple plot or, in this case, a bunch of them, &#xA0;since we have few variables and files.</p><pre><code class="language-matlab">%% Plot the data available, just to have a quick overview
figure(&apos;Position&apos;, [10 10 1200 400])
tiledlayout(&apos;flow&apos;, &apos;TileSpacing&apos;, &apos;compact&apos;)

for i_plot = 2:size(t1,2)
    
    nexttile
    plot(t1.Time_s, t1{:, i_plot}, &apos;DisplayName&apos;, &apos;1&apos;)
    hold on
    plot(t2.Time_s, t2{:, i_plot}, &apos;DisplayName&apos;, &apos;2&apos;)
    title(t1.Properties.VariableNames{i_plot}, &apos;Interpreter&apos; , &apos;none&apos;)
    legend
    
end
</code></pre><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2022/09/DATA_plot_MATLAB-1.jpg" class="kg-image" alt="Using MATLAB and statistics to analyze raw vehicle data" loading="lazy" width="2000" height="667" srcset="http://localhost:2368/content/images/size/w600/2022/09/DATA_plot_MATLAB-1.jpg 600w, http://localhost:2368/content/images/size/w1000/2022/09/DATA_plot_MATLAB-1.jpg 1000w, http://localhost:2368/content/images/size/w1600/2022/09/DATA_plot_MATLAB-1.jpg 1600w, http://localhost:2368/content/images/size/w2400/2022/09/DATA_plot_MATLAB-1.jpg 2400w" sizes="(min-width: 720px) 720px"><figcaption>Time series plots of the data stored in the files. This is useful to visualize what kind of information we have.</figcaption></figure><p>Great! we have comparable data in both files. We have pressure data from a sensor in the hydraulic circuit of the car, raw acceleration data from an <a href="https://en.wikipedia.org/wiki/Inertial_measurement_unit">IMU</a>, and the rotational speed of the four motors attached to the wheels. There is a slight time offset between the two data sets, and one of them is a bit longer. This is raw data, so it is something completely normal. </p><p>Let&#x2019;s find out which driver was faster. &#xA0;To do this, we need to compute the vehicle speed. </p><hr><h3 id="estimating-the-vehicle-speeds">Estimating the vehicle speeds</h3><p></p><p>This is not easy at all - it might seem, <a href="http://dx.doi.org/10.26552/com.C.2021.2.B117-B129">but it is not</a> - at least if you want to do it accurately. What we can do is settle for a simplified calculation assuming the following:</p><ul><li>When the vehicle is accelerating, the speed of the car is similar to the speed of the contact point of the slowest tire, i.e. the one that rotates slower than the others and thus has a smaller <a href="https://www.racecar-engineering.com/tech-explained/tyre-dynamics/#:~:text=The%20slip%20ratio%20is%20similar,tyre%20that%20has%20lost%20traction">slip ratio</a>.</li><li>On the other hand, when the car is braking, the slowest tire is most likely locked, with a higher absolute slip ratio than the others. So in this case the vehicle&apos;s speed is closer to that of the fastest spinning tire - no accelerating torque is present.</li></ul><p>This is a rough estimate but should be enough for this analysis. But before we do this, we need to do some work to clean up the raw acceleration data. I will remove the <a href="https://en.wikipedia.org/wiki/DC_bias">DC offset</a>, and filter the noise.</p><pre><code class="language-MATLAB">%% Filter the longitudinal acceleration

% Compute the sum of the wheel speeds
sum_of_speeds1 = t1.spd_rpmFR + t1.spd_rpmFL + t1.spd_rpmRR + t1.spd_rpmRL;
sum_of_speeds2 = t2.spd_rpmFR + t2.spd_rpmFL + t2.spd_rpmRR + t2.spd_rpmRL;

% Remove any DC - offset from the raw acceleration data
t1.AccXNoOffs = t1.AccX - median(table2array(t1(sum_of_speeds1 == 0, &apos;AccX&apos;)));
t2.AccXNoOffs = t2.AccX - median(table2array(t2(sum_of_speeds2 == 0, &apos;AccX&apos;)));

% Filter the signals
t1.AccX = sgolayfilt(t1.AccXNoOffs, 3, 101);
t2.AccX = sgolayfilt(t2.AccXNoOffs, 3, 101);

% COmpare the signals
figure(&apos;Position&apos;, [10 10 1200 400]);
hold on
plot(t1.Time_s, t1.AccXNoOffs, &apos;-k&apos;, &apos;DisplayName&apos;, &apos;Raw AccX (removed DC offset)&apos;, &apos;linewidth&apos;, .5)
plot(t1.Time_s, t1.AccX, &apos;-r&apos;, &apos;DisplayName&apos;, &apos;AccX (filtered)&apos;, &apos;linewidth&apos;, 1.5 )
xlim([600, 650])
xlabel(&apos;Time [seconds]&apos;)
ylabel(&quot;Acceleration [G - units]&quot;)
legend
grid minor
</code></pre><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2022/09/raw_vs_filtered_Acc_MATLAB.jpg" class="kg-image" alt="Using MATLAB and statistics to analyze raw vehicle data" loading="lazy" width="2000" height="667" srcset="http://localhost:2368/content/images/size/w600/2022/09/raw_vs_filtered_Acc_MATLAB.jpg 600w, http://localhost:2368/content/images/size/w1000/2022/09/raw_vs_filtered_Acc_MATLAB.jpg 1000w, http://localhost:2368/content/images/size/w1600/2022/09/raw_vs_filtered_Acc_MATLAB.jpg 1600w, http://localhost:2368/content/images/size/w2400/2022/09/raw_vs_filtered_Acc_MATLAB.jpg 2400w" sizes="(min-width: 720px) 720px"></figure><!--kg-card-begin: markdown--><p>I filtered the acceleration signals using a Finite-Impulse-Response filter, in this case, a Savitzky&#x2013;Golay filter. This type of filter does a good job preserving the height and location of the peaks and the area below them. Implementing this type of filter in MATLAB is as simple as just typing the <a href="https://it.mathworks.com/help/signal/ref/sgolayfilt.html">sgolay</a> command and including some parameters <a href="https://nirpyresearch.com/choosing-optimal-parameters-savitzky-golay-smoothing-filter/">chosen accordingly</a>. <em>But only if you have the Signal Processing Toolbox license</em>. So this might be one of the reasons to consider using free software options. Of course, with a little more work, you can implement a similar filter yourself using &#x201C;standard&#x201D; MATLAB commands. (edit: if you actually check the book <a href="https://www.ece.rutgers.edu/~orfanidi/intro2sp/"><em>Introduction to Signal Processing</em></a> cited in the MATLAB documentation of the filter, you can actually see the implementation for many types of digital filters both in MATLAB and C, and download the files. Cool!)</p>
<!--kg-card-end: markdown--><p>Now, how to determine the vehicle speed using the approach I mentioned before?</p><p>Easy, right? Just make a <code>for</code> loop and iterate through the rows of the table. When the acceleration is positive take the minimum wheel speed, when it is negative, take the maximum one. And of course, convert each value to linear speed.</p><pre><code class="language-matlab">%% Estimate the vehicle speed: the for-loop way
% Extract the wheel rotational speed data from the two files
wRPM1 = t1(:,{&apos;spd_rpmFL&apos;, &apos;spd_rpmFR&apos;, &apos;spd_rpmRL&apos;, &apos;spd_rpmRR&apos;}); 
wRPM2 = t2(:,{&apos;spd_rpmFL&apos;, &apos;spd_rpmFR&apos;, &apos;spd_rpmRL&apos;, &apos;spd_rpmRR&apos;});

tic
for i_ax1=1:height(wRPM1)
    
   if t1.AccX(i_ax1,1)&gt;0
       VEL1_for(i_ax1,1)=min(wRPM1{i_ax1,:})*(pi/30)*r/gear_ratio*3.6;
   else
       VEL1_for(i_ax1,1)=max(wRPM1{i_ax1,:})*(pi/30)*r/gear_ratio*3.6;
   end
end
toc % Elapsed time is 289.592689 seconds. &lt;--- NOT GOOD!
</code></pre><p>That took forever! I don&apos;t want to wait that much time when doing this kind of thing! What if the data grows larger, or if I need to compare 100 files instead of 2, should I wait 4 hours? Maybe my PC is not the fastest, but there has to be a better way! </p><p>Fortunately, yes, there is a better way. We can use indexing methods instead of for loops.</p><pre><code class="language-matlab">%% Estimate the vehicle speed: Release the power of table indexing
tic

% Create empty columns for storing the vehicle speed
t1.Veh_Spd = zeros(height(t1), 1);
t2.Veh_Spd = zeros(height(t2), 1);

t1(t1.AccX &gt; 0, &apos;Veh_Spd&apos;) = table(min(t1{t1.AccX &gt; 0,...
    {&apos;spd_rpmFL&apos;,&apos;spd_rpmFR&apos;,&apos;spd_rpmRL&apos;,&apos;spd_rpmRR&apos;}}, [], 2)*pi/30*r/gear_ratio*3.6);
t1(t1.AccX &lt;= 0, &apos;Veh_Spd&apos;) = table(max(t1{t1.AccX &lt;= 0,...
    {&apos;spd_rpmFL&apos;,&apos;spd_rpmFR&apos;,&apos;spd_rpmRL&apos;,&apos;spd_rpmRR&apos;}}, [], 2)*pi/30*r/gear_ratio*3.6);     

t2(t2.AccX &gt; 0, &apos;Veh_Spd&apos;) = table(min(t2{t2.AccX &gt; 0,...
    {&apos;spd_rpmFL&apos;,&apos;spd_rpmFR&apos;,&apos;spd_rpmRL&apos;,&apos;spd_rpmRR&apos;}}, [], 2)*pi/30*r/gear_ratio*3.6);
t2(t2.AccX &lt;= 0, &apos;Veh_Spd&apos;) = table(max(t2{t2.AccX &lt;= 0,...
    {&apos;spd_rpmFL&apos;,&apos;spd_rpmFR&apos;,&apos;spd_rpmRL&apos;,&apos;spd_rpmRR&apos;}}, [], 2)*pi/30*r/gear_ratio*3.6);
    
toc % Elapsed time is 0.018584 seconds.
</code></pre><p>Awesome! we get both velocity vectors in just a fraction of a second, instead of only one in 5 minutes. I just took advantage of the indexing capabilities of MATLAB - it was designed to work with matrix operations, so why not use them? &#xA0;Let me explain a bit:</p><p>I first added empty columns to the tables. Then, I indexed the tables, selecting only the rows for which the acceleration was positive, and the empty column I just created.</p><p>In that selection, I inserted the minimum of the motor speeds for each row, again, considering only the rows for which the acceleration was positive, and converting that to linear speeds. </p><p>Then I did the same for the opposite case when the acceleration was negative.</p><p>A similar approach can be used to avoid <code>for</code> loops when using numeric arrays or cell arrays instead of tables. The difference is just the syntax for indexing them.</p><p>Moving on...</p><hr><h3 id="comparing-the-speeds-of-both-drivers">Comparing the speeds of both drivers</h3><p></p><p>Let&#x2019;s see what we&#x2019;ve got as vehicle speeds:</p><p></p><pre><code class="language-matlab">%% Create a figure with tiled layout
                                                
time_series = figure(&apos;Name&apos;, [&apos;Time series comparison&apos;], &apos;Position&apos;, [10 10 1200 400]);
tiles = tiledlayout(2,1);
title(tiles, &apos;Driver time comparison&apos;)
xlabel(tiles, &apos;Time [s]&apos;)

%% Plot data from the first file

nexttile
plot(t1.Time_s, t1.Veh_Spd, &apos;-b&apos;)
xlim([0, 1200])
ylim([0, 100])
ylabel(&apos;Vehicle speed [km/h]&apos;)
hold on
time_start1 = t1.Time_s(min(find( t1.Veh_Spd &gt; 20)));
time_end1 = t1.Time_s(max(find(t1.Veh_Spd &gt; 20)));
t_elap_1 = time_end1 - time_start1;

plot([[time_start1 time_end1]; [time_start1 time_end1] ], ...
    repmat(ylim&apos;,1, 2), &apos;Color&apos;, &apos;k&apos;, &apos;LineWidth&apos;, 2);
title([&apos;Driver 1 approximate time: &apos; num2str(time_end1 - time_start1, &apos;%0.1f&apos;) &apos; seconds&apos;...
       newline &apos;Max. Speed: &apos; num2str(max(t1.Veh_Spd), &apos;%0.0f&apos;) &apos;km/h, &apos;...
       &apos;Mean Speed: &apos; num2str(mean(t1.Veh_Spd, &apos;omitnan&apos;), &apos;%0.0f&apos;) &apos;km/h&apos;])
grid minor


%% Plot data from the second file

nexttile
plot(t2.Time_s, t2.Veh_Spd, &apos;-b&apos;)
xlim([0, 1200])
ylim([0, 100])
ylabel(&apos;Vehicle speed [km/h]&apos;)
hold on
time_start2 = t2.Time_s(min(find(t2.Veh_Spd &gt; 20)));
time_end2 = t2.Time_s(max(find(t2.Veh_Spd &gt; 20)));
t_elap_1 = time_end1 - time_start1;
        

plot([[time_start2 time_end2]; [time_start2 time_end2] ], repmat(ylim&apos;,1, 2), &apos;Color&apos;, &apos;k&apos;, &apos;LineWidth&apos;, 2);
grid minor
title([&apos;Driver 2 approximate time: &apos; num2str(time_end2 - time_start2, &apos;%0.1f&apos;) &apos; seconds&apos;...
       newline &apos;Max. Speed: &apos; num2str(max(t2.Veh_Spd), &apos;%0.0f&apos;) &apos;km/h, &apos;...
       &apos;Mean Speed: &apos; num2str(mean(t2.Veh_Spd, &apos;omitnan&apos;), &apos;%0.0f&apos;) &apos;km/h&apos;])</code></pre><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2022/09/Drivers_time_plot_MATLAB-3.jpg" class="kg-image" alt="Using MATLAB and statistics to analyze raw vehicle data" loading="lazy" width="2000" height="667" srcset="http://localhost:2368/content/images/size/w600/2022/09/Drivers_time_plot_MATLAB-3.jpg 600w, http://localhost:2368/content/images/size/w1000/2022/09/Drivers_time_plot_MATLAB-3.jpg 1000w, http://localhost:2368/content/images/size/w1600/2022/09/Drivers_time_plot_MATLAB-3.jpg 1600w, http://localhost:2368/content/images/size/w2400/2022/09/Drivers_time_plot_MATLAB-3.jpg 2400w" sizes="(min-width: 720px) 720px"></figure><p>Ok, the second driver was<em> </em><strong><em>a lot</em> </strong>faster. There could be very noticeable differences in the driving styles since they were using the same car. So let&#x2019;s see If we can spot them. First, let&#x2019;s look at their speeds from a statistical perspective:</p><p></p><pre><code class="language-matlab">%% Get statistics about the driving speeds                                               
histograms = figure(&apos;Name&apos;, [&apos;Histograms comparison&apos;], &apos;Position&apos;, [10 10 1200 400]);
tiles = tiledlayout(2,1);
title(tiles, &apos;Comparing vehicle speed data using histograms&apos;)
xlabel(tiles, &apos;Vehicle speed [km/h]&apos;)
binEdges = 0:5:100;

nexttile
VEL1 = t1.Veh_Spd;
VEL2 = t2.Veh_Spd;
n_vel=max(numel(VEL1),numel(VEL2));

VEL1(end+1:n_vel)=nan;
VEL2(end+1:n_vel)=nan;
% &quot;Old&quot; method for creating a histogram
hist([VEL1, VEL2], binEdges);
ylabel(&apos;Counts&apos;)

legend(&apos;Driver 1&apos;, &apos;Driver 2&apos;)
title(&apos;Bar plots of histogram data (hist command)&apos;)
grid on

nexttile
% Newer way of creating a histogram
h1 = histogram(t1.Veh_Spd, binEdges, &apos;normalization&apos; , &apos;pdf&apos;)
hold on
h2 = histogram(t2.Veh_Spd, binEdges, &apos;normalization&apos; , &apos;pdf&apos;)
legend(&apos;Driver 1&apos;, &apos;Driver 2&apos;)
title(&apos;Plotting two overlapping histograms (histogram command)&apos;)
ylabel(&apos;Probability&apos;)
grid on

%% Get some descriptive parameters
v1_mean = mean(t1.Veh_Spd, &apos;omitnan&apos;)       % Means of the two samples
v2_mean = mean(t2.Veh_Spd, &apos;omitnan&apos;)
v1_median = median(t1.Veh_Spd, &apos;omitnan&apos;)	% Medians of the two samples
v2_median = median(t2.Veh_Spd, &apos;omitnan&apos;)
v1_std = std(t1.Veh_Spd, &apos;omitnan&apos;)         % Standard deviations of the two samples
v2_std = std(t2.Veh_Spd, &apos;omitnan&apos;)
</code></pre><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2022/09/histogram_Speed_MATLAB-2.jpg" class="kg-image" alt="Using MATLAB and statistics to analyze raw vehicle data" loading="lazy" width="2000" height="667" srcset="http://localhost:2368/content/images/size/w600/2022/09/histogram_Speed_MATLAB-2.jpg 600w, http://localhost:2368/content/images/size/w1000/2022/09/histogram_Speed_MATLAB-2.jpg 1000w, http://localhost:2368/content/images/size/w1600/2022/09/histogram_Speed_MATLAB-2.jpg 1600w, http://localhost:2368/content/images/size/w2400/2022/09/histogram_Speed_MATLAB-2.jpg 2400w" sizes="(min-width: 720px) 720px"><figcaption>Two different ways of plotting histograms in MATLAB. There is also the &quot;bar&quot; command.</figcaption></figure><p>The histograms on the right side are normalized so that we can compare both files, even if the time of the second driver was shorter - which means that we have fewer data points. By dividing the counts of each bin by the size of the total sample, we actually get a representation of the discrete probability density function.</p><hr><h3 id="analyzing-the-braking-pressures">Analyzing the braking pressures</h3><p></p><p>The histograms show that the second driver spent more time at speeds above 60 km/h than the first one. &#xA0;But both drivers were using exactly the same car. And the mean and median speed values are not that different between the two. So what could have changed? Perhaps it is also important to see how they were using the brakes.</p><pre><code class="language-matlab">%% Create histograms of the braking pressures
% This considers only the use of mechanical brakes.
% The electric car can also use the electric motors for regenerative braking. 
% This is enabled through a small portion of the brake pedal travel.
% These two particular datalogs do not contain information about that, so we will
% focus on the mechanical (hydraulic) brakes.

t1.BrakeFront(t1.BrakeFront &lt;=0) = 0; %filter negative pressure values
t2.BrakeFront(t2.BrakeFront &lt;=0) = 0; %filter negative pressure values
%%
figure;
hold on
histogram(t2.BrakeFront, &apos;Normalization&apos;, &apos;cdf&apos;)
histogram(t1.BrakeFront, &apos;Normalization&apos;, &apos;cdf&apos;)
set(gca,&apos;YScale&apos;,&apos;log&apos;)
ylabel(&apos;cumcount (log scale)&apos;)
xlabel(&apos;Pressure [bar]&apos; )
title(&apos;Brakes pressure in the front circuit &apos;)
legend( &apos;Driver 2&apos;, &apos;Driver 1&apos;)
grid on
</code></pre><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2022/09/pressure_hist_cumcount_MATLAB-1.jpg" class="kg-image" alt="Using MATLAB and statistics to analyze raw vehicle data" loading="lazy" width="2000" height="759" srcset="http://localhost:2368/content/images/size/w600/2022/09/pressure_hist_cumcount_MATLAB-1.jpg 600w, http://localhost:2368/content/images/size/w1000/2022/09/pressure_hist_cumcount_MATLAB-1.jpg 1000w, http://localhost:2368/content/images/size/w1600/2022/09/pressure_hist_cumcount_MATLAB-1.jpg 1600w, http://localhost:2368/content/images/size/w2400/2022/09/pressure_hist_cumcount_MATLAB-1.jpg 2400w" sizes="(min-width: 720px) 720px"><figcaption>Cumulative count density of the pressures in the hydraulic circuits. &apos;Density&apos; means the counts for each bin have been normalized to the total number of counts, this way we can compare the distributions even if the samples have different sizes.</figcaption></figure><p></p><p>The bars on the left side represent the low-pressure values, which are the most common values present during driving. This makes sense since one doesn&#x2019;t drive with the brakes pressed, especially during a race. However, we can see that the number of times that the brakes were completely disengaged was lower for driver 1. And we also see that the number of instants with low braking pressures - around 5 bar - is higher in case 1. This could mean that the first driver actually had the brakes slightly pressed constantly, perhaps without noticing. Driver 1 also pushed the brakes to higher pressures (up to 40 bar, which probably was the full-scale reading of the pressure sensor).</p><p>Let&#x2019;s see also at what speeds the drivers were braking. </p><hr><h3 id="finding-the-vehicle-speeds-at-the-start-of-the-braking-maneuvers">Finding the vehicle speeds at the start of the braking maneuvers</h3><p></p><p>To do this, we need to identify the speeds at the start of the braking maneuvers. I defined a small pressure value to use as a threshold for identifying when the brakes are pressed. This is a bit of an iterative process - you don&#x2019;t get it right the first time and need to adjust the value until the results make sense.</p><!--kg-card-begin: markdown--><p>Let&apos;s use again the power of indexing, I don&apos;t want to wait forever with a for loop. We just need to determine in which rows there was a change in pressure that we could recognize as a pedal press. We also need to consider only the cases in which the vehicle was actually moving. So we have three conditions:</p>
<ol>
<li>Low pressure on instant t</li>
<li>High pressure (greater than a threshold) on instant t+1</li>
<li>Vehicle speed greater than a minimum value at instant t+1</li>
</ol>
<p>I indexed the tables using these three conditions and used parentheses to make them more readable (they are not really needed for the code to work). The trick is to impose the second and third conditions (t+1) by indexing the table from the second row. This creates the shift in time values that we would normally obtain using a loop with an increasing counter:</p>
<!--kg-card-end: markdown--><p></p><pre><code class="language-matlab">%% Find the index of the start of braking

%Define a pressure threshold value to consider as start of braking
p_start = 2; % bar

% Create indices for the start of the braking maneuvers
id_start1 = (t1.BrakeFront &lt;= p_start) &amp; ([t1.BrakeFront(2:end);0] &gt; p_start) &amp; ([t1.Veh_Spd(2:end); 0] &gt;= 15);
id_start2 = (t2.BrakeFront &lt;= p_start) &amp; ([t2.BrakeFront(2:end);0] &gt; p_start) &amp; ([t2.Veh_Spd(2:end); 0] &gt;= 15);

%% Verify that the identified points make sense
figure
plot(t1.Time_s, t1.BrakeFront, &apos;b&apos;, &apos;LineWidth&apos;, 1,&apos;DisplayName&apos;, &apos;Pressure&apos;)
hold on
x = [t1.Time_s(id_start1), t1.Time_s(id_start1)];

% Show a black vertical line at the start of each braking maneuver
line(x, ylim, &apos;Color&apos;, &apos;k&apos;, &apos;LineWidth&apos;, .5, &apos;HandleVisibility&apos;, &apos;off&apos;); 
yline(p_start, &apos;DisplayName&apos;, &apos;Brake start threshold&apos; ,&apos;LineWidth&apos;, 2) 
ylabel(&apos;Pressure [bar]&apos; )
yyaxis right

plot(t1.Time_s, t1.Veh_Spd, &apos;r&apos;, &apos;LineWidth&apos;, 1, &apos;DisplayName&apos;, &apos;Vehicle Spd&apos;)
set(gca, &apos;Ycolor&apos;, &apos;r&apos;)
ylabel(&apos;Vehicle speed [km/h]&apos;)
xlabel(&apos;Time [s]&apos; ), xlim([750, 800])
legend, grid on
</code></pre><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2022/09/Start_of_brake_MATLAB-1.jpg" class="kg-image" alt="Using MATLAB and statistics to analyze raw vehicle data" loading="lazy" width="2000" height="667" srcset="http://localhost:2368/content/images/size/w600/2022/09/Start_of_brake_MATLAB-1.jpg 600w, http://localhost:2368/content/images/size/w1000/2022/09/Start_of_brake_MATLAB-1.jpg 1000w, http://localhost:2368/content/images/size/w1600/2022/09/Start_of_brake_MATLAB-1.jpg 1600w, http://localhost:2368/content/images/size/w2400/2022/09/Start_of_brake_MATLAB-1.jpg 2400w" sizes="(min-width: 720px) 720px"></figure><hr><p>Great! we have identified the starts of braking maneuvers. Now let&#x2019;s look at the speeds at which the drivers started braking. We just have to create histograms of the vehicle speeds using the indices we just found:</p><p></p><pre><code class="language-MATLAB">%% Create histograms and plot them
                                                
histograms = figure(&apos;Name&apos;, [&apos;Histograms comparison&apos;], &apos;Position&apos;, [10 10 900 600]);
title(&apos;MATLAB figure&apos;)
xlabel(&apos;Vehicle speed [km/h]&apos;)
binEdges = 10:5:100;

histogram(t1.Veh_Spd(id_start1), binEdges, &apos;Normalization&apos; , &apos;probability&apos;)
hold on
histogram(t2.Veh_Spd(id_start2), binEdges, &apos;Normalization&apos; , &apos;probability&apos;)
legend(&apos;Driver 1&apos;, &apos;Driver 2&apos;)
ylabel(&apos;Probability&apos;)
xlabel(&apos;Vehicle speed at the start of braking [km/h]&apos;)
grid on
</code></pre><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2022/09/VEL_start_brakin_MATLAB-3.jpg" class="kg-image" alt="Using MATLAB and statistics to analyze raw vehicle data" loading="lazy" width="2000" height="667" srcset="http://localhost:2368/content/images/size/w600/2022/09/VEL_start_brakin_MATLAB-3.jpg 600w, http://localhost:2368/content/images/size/w1000/2022/09/VEL_start_brakin_MATLAB-3.jpg 1000w, http://localhost:2368/content/images/size/w1600/2022/09/VEL_start_brakin_MATLAB-3.jpg 1600w, http://localhost:2368/content/images/2022/09/VEL_start_brakin_MATLAB-3.jpg 2250w" sizes="(min-width: 720px) 720px"></figure><p>Looking at the histograms, we can see that the first driver initiated more braking maneuvers between 60 and 70 km/h, but he also initiated more braking maneuvers at lower speeds - below 55 km/h. The second driver was braking at higher speeds. </p><hr><p>This was a simple toy example of how to use MATLAB to do some tasks with real-world data. We used histograms to get valuable insights from the data, something that would not be easy if we just used time series plots to visualize the two datasets.</p><p>Sometimes we can be too concerned with the time-based evolution of the data we are looking at, rather than their distribution, or the trends and correlations between different variables.</p><p>Seeing how histograms can be easily used to get insights without actually needing to look at the times series can sometimes open a new perspective when looking at data recorded from physical things (cars, machines, sensors, etc).</p><p>Hopefully, this example was useful or interesting for you if you are just getting started doing similar things. I would be glad if it was in any way :) </p><p>In the next entry, I will repeat the analysis (at least the main part) using Python instead of MATLAB. Stay tuned!</p>]]></content:encoded></item><item><title><![CDATA[Replacing MATLAB with Python - Part 1]]></title><description><![CDATA[Stick with me in this series of posts if you want to see some examples of using Python for MATLAB users. I am not an expert, and the code I will share can probably be improved, but I think these practical examples can be useful for a beginner like me.]]></description><link>http://localhost:2368/replacing-matlab-with-python-part-1/</link><guid isPermaLink="false">62e81ab9566ade6d90ed3bc2</guid><category><![CDATA[Python]]></category><category><![CDATA[MATLAB]]></category><category><![CDATA[Engineering]]></category><category><![CDATA[Data]]></category><dc:creator><![CDATA[Luis Medina]]></dc:creator><pubDate>Sat, 20 Aug 2022 08:32:32 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1497285597995-6ed7de6bfebd?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDE3fHxvcGVufGVufDB8fHx8MTY2MDk4NTE3NQ&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1497285597995-6ed7de6bfebd?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDE3fHxvcGVufGVufDB8fHx8MTY2MDk4NTE3NQ&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Replacing MATLAB with Python - Part 1"><p>I work a full-time job as an automotive Control Systems Engineer, and - usually - a big chunk of my time during the day is employed using MATLAB/Simulink for different types of tasks.</p><p>I recently spent a couple of weeks without an individual MATLAB license at work due to different issues that I am not going to address. Of course, I had the chance to use workstations with shared licenses in the office to continue working in <a href="https://en.wikipedia.org/wiki/Model-based_design#:~:text=Model%2Dbased%20design%20(MBD),%2C%20aerospace%2C%20and%20automotive%20applications.">Model-Based software development</a>. For that kind of activity, you can&apos;t just go around the license problem, since you work on shared files and projects within a team, and you need to produce models (code) that are part of a larger project.</p><!--kg-card-begin: markdown--><p>However, I took the chance to sharpen my Python skills while completing some of the other tasks I had to do, mainly when analyzing data. I could have used other alternatives, like <a href="https://octave.org/">GNU Octave</a> - which even has the same MATLAB syntax, or <a href="https://www.scilab.org/">Scilab</a>. But I wanted to learn more about Python, since it is a <em>general-purpose programming language</em>.</p>
<p>I figured that I could share some of the things I learned, and started to write an article that suddenly was too long for a single post. So this will be an ongoing series of posts. In each entry, I will share a simple but practical example of how to do a certain task with MATLAB, but using Python instead. Probably some of the code can be improved, but I think it can be useful to see these examples if you are a beginner like me.</p>
<p>I think this is important since Python opens the possibilities for individuals and companies that cannot afford to buy an expensive MATLAB license, or that already using MATLAB but have use cases for which MATLAB can be easily replaced with Python, cutting down the license costs.</p>
<p>MATLAB is still being used widely, especially in the Automotive and Aerospace industries, but the usage of Python has grown dramatically in many different sectors, since it can be used for many other things - like I said, general-purpose. <em>Python cannot really be compared with MATLAB, as they were designed for different purposes</em>, but I will focus on the use cases that can overlap between the two of them.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/3045_RC01/embed_loader.js"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"/m/05z1_","geo":"","time":"2004-01-01 2022-08-12"},{"keyword":"/m/053_x","geo":"","time":"2004-01-01 2022-08-12"}],"category":0,"property":""}, {"exploreQuery":"date=all&q=%2Fm%2F05z1_,%2Fm%2F053_x","guestPath":"https://trends.google.com:443/trends/embed/"}); </script><!--kg-card-end: html--><p></p><!--kg-card-begin: markdown--><h2 id="about-automotive-file-formats-and-data-extraction">About Automotive file formats and data extraction</h2>
<p><em>Skip this part if you are not interested in automotive-specific data</em></p>
<!--kg-card-end: markdown--><p>Extracting and doing the first-level analysis of data from large log files is a very common use case of MATLAB in automotive testing environments - at least from what I&apos;ve seen in three different large companies in Europe. It could be seen as a mundane activity, but it is not straightforward if the files you have are in different formats. Also, &#xA0;it might be something you need to do very frequently. </p><p><strong><em>For this series of posts, I will look at the tasks I learned to do with Python once the data was available in some kind of universal text encoding.</em> </strong>For instance a CSV file or an ASCII file. This is not always obvious, and there were many cases in which I needed to convert <a href="https://support.vector.com/kb?id=kb_article_view&amp;sysparm_article=KB0011536">VECTOR CAN log files </a>or other <a href="https://www.asam.net/standards/detail/mdf/wiki/#:~:text=An%20ASAM%20MDF%20file%20(file,the%20block&apos;s%20purpose%20and%20content.">ASAM standard formats</a> to text, or use some kind of API to be able to work with them in Python or MATLAB. But that will be part of another article later on.</p><!--kg-card-begin: markdown--><h1 id="how-to-start-using-python">How to start using Python?</h1>
<p>First of all: this will not be a Python course. I am assuming you have already some basic understanding and want to see some basic examples of how to use it. You can learn the basics very quickly with tons of free tutorials and courses out there. I followed the <em>Scientific Computing with Python Certification</em> on <a href="https://www.freecodecamp.org/learn/scientific-computing-with-python/">FreeCodeCamp.org</a> a while ago, and it was great to grab the basics. There are also great resources like <a href="https://www.techwithtim.net/">TechWithTim.net</a>, and many courses on <a href="https://www.coursera.org/specializations/python">Coursera</a>, <a href="https://www.edx.org/learn/python">EdX</a>, <a href="https://www.datacamp.com/courses/intro-to-python-for-data-science">DataCamp</a>, and others.</p>
<p>Python can be actually written in any raw text editor, like <a href="https://www.chip.de/downloads/Notepad_12996935.html">Numpad++ </a>, and then run from the Windows command prompt. But you probably don&apos;t want to do that.</p>
<p>If you are coming from MATLAB and want to start using Python, you probably want some kind of user interface or IDE (Integrated Development Environment) to work with. There is no unique or best answer here, so I will just tell you about the ones I have tried.</p>
<p>The first thing is, of course, to download and install <a href="https://www.python.org/downloads/">Python 3 itself</a> (Python 2 is already in an End-of-Life stage and will no longer be supported by new libraries). Then, you can download and install one of the following IDEs:</p>
<ol>
<li><a href="https://jupyterlab.readthedocs.io/en/stable/">Jupyter Labs</a>. Probably the most used interface for working with Python nowadays. It allows you to work on your web browser, and the Jupyter Notebooks allow splitting the code into <em>cells</em> that can be run individually, as we do with MATLAB&apos;s <em>code sections</em>.</li>
<li><a href="https://www.spyder-ide.org/">SPyder IDE</a>. In my opinion, this one provides the closest experience to MATLAB in terms of interface. You can even have a panel to look at the variables you are working with, for example, and interactive plots. You can install add-ins to work with Jupyter Notebooks within the Spyder IDE too.</li>
<li><a href="https://code.visualstudio.com/">Visual Studio Code</a> (VS Code) This is a more general-purpose programming IDE, but has great support for Python, including support for Jupyter Notebooks too.</li>
</ol>
<p>Personally, I prefer to use VS Code since it allows me to work also on other types of programming projects in the same environment, for example when working with Arduino. However, the code examples I will share will work no matter the IDE you are using.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>Ok! enough with the introduction, let&apos;s jump to the first and most simple example of this series.</p>
<hr>
<h2 id="example-1-simple-time-series-visualization">Example 1: Simple time series visualization</h2>
<!--kg-card-end: markdown--><p>Normally, working with MATLAB or not, the first thing to do after loading data from some large file would be to plot a time series of the most interesting data (or signals, if we are talking about a CAN data log file, for example). This way I can at least know what I&#x2019;m dealing with. For this example, I will use this <a href="https://drive.google.com/file/d/1SntfHfiLiTw1Oucy80MRuj8r9WnVa807/view?usp=sharing">example file</a>, which contains some CAN data from a Formula Student Electric car.</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://drive.google.com/file/d/1SntfHfiLiTw1Oucy80MRuj8r9WnVa807/view"><div class="kg-bookmark-content"><div class="kg-bookmark-title">test_FSCar_ddMMYYYY_TrackN_setupID2.csv</div><div class="kg-bookmark-description"></div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://ssl.gstatic.com/images/branding/product/1x/drive_2020q4_32dp.png" alt="Replacing MATLAB with Python - Part 1"><span class="kg-bookmark-author">Google Docs</span></div></div></a></figure><p>If you download the file, you&apos;ll notice that there are missing values on each variable (CAN signal). This happens a lot especially if you have CAN data, which travels in packets, sometimes at different rates. When the data is exported to other formats, there are different ways to handle the different rates of the signals. In some cases, you will get an output file containing data with individual time vectors for each signal. In this case, the user preferred to have a single time base in the exported file, common to all signals, but the drawback is that there are empty values. I personally prefer this way, since it is easier to do time-based analyses with a unique time vector. We just need to handle the empty values.</p><p>To look at this file with MATLAB, I would do something like this:</p><!--kg-card-begin: html--><script src="https://gist.github.com/luisdamed/77e6fff0c5cc9f0bd5a082af0535df3d.js"></script><!--kg-card-end: html--><p></p><p>Notice that I extracted the indices of the non-empty values of each signal, and then used that to represent the data. &#xA0;I also did some formatting to the plot to make it understandable. </p><p>I needed to represent data containing information about speed, in rpm, and torque, in Nm. And I wanted to visualize both against the same time scale, in order to understand what happened during the test I am looking at. </p><!--kg-card-begin: markdown--><p>This is why I created a tiled layout. I could have used <a href="https://it.mathworks.com/help/matlab/ref/subplot.html">subplots</a> instead, and the results would have been very similar. Or I could have plotted both speeds and rpm against a single abscissa, but using two different y axes using <code>yyaxis right</code>.</p>
<!--kg-card-end: markdown--><p>The output will be something like this:</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2022/08/MATLAB_figure_timeseries-2.png" class="kg-image" alt="Replacing MATLAB with Python - Part 1" loading="lazy" width="1078" height="701" srcset="http://localhost:2368/content/images/size/w600/2022/08/MATLAB_figure_timeseries-2.png 600w, http://localhost:2368/content/images/size/w1000/2022/08/MATLAB_figure_timeseries-2.png 1000w, http://localhost:2368/content/images/2022/08/MATLAB_figure_timeseries-2.png 1078w" sizes="(min-width: 720px) 720px"><figcaption>Plot of time series data obtained using MATLAB - Image by author</figcaption></figure><p>Simple enough, right? Let&apos;s see what we have to do instead when using Python.</p><hr><!--kg-card-begin: html--><script src="https://gist.github.com/luisdamed/34eba609e5877f2181dcec84be5190e3.js"></script><!--kg-card-end: html--><!--kg-card-begin: markdown--><p>The first difference you&apos;ll notice is that we need to import the Python libraries we&apos;ll use at the start of the code. In this case, we are dealing with data from a text file, so it is a common practice to use the library called Pandas. Although it can be slow for doing complex computations or handling large datasets, there are some workarounds.  In general, it is better to do the calculations using another library, Numpy. We simply import those using the <code>import</code> command before using anything from them.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>Then we can read the file, and load the data as a Pandas dataframe. In Python, we have to get used to working with <em>methods</em> other than functions. This will allow us to do different things with the variables we are working with, depending on what type of object (class) they are. For instance, we loaded the data from the file as a dataframe object that we called <code>df</code> (we could have called it anything, like <code>Pikachu</code>, if we wanted, but <code>df</code> is more self-explanatory and common practice). Then, to extract the non-empty values we use the <code>.</code> notation to access the <code>notnull()</code> method of the dataframe class.</p>
<p>This is different from the function-based approach that I used in the MATLAB script above, where I used the <a href="https://it.mathworks.com/help/matlab/ref/isnan.html#mw_db2dcfa9-acb4-48e9-a017-ee0c39f1f741"><code>isnan</code></a> function, and it would have worked on either a double array, a scalar, a matrix or a multidimensional array.</p>
<p>However, methods and classes are not unique to Python, they exist in almost any programming language, and even in MATLAB. The difference is how they are used depending on the <em>intent</em> of the language. MATLAB is specific for matrix computations, so it relies heavily on functions, whereas Python has specific libraries for different purposes, and they use both functions and methods to accomplish some tasks. There are also some <a href="https://docs.python.org/3/library/functions.html">built-in functions in Python</a></p>
<p>Next, we create the figure and plot the data. We first need to specify the figure size, otherwise, the default figure dimensions will be too small. In this case, we are using subplots to obtain the following result:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2022/08/Python_fig_timeseries-1.jpeg" class="kg-image" alt="Replacing MATLAB with Python - Part 1" loading="lazy" width="1800" height="1200" srcset="http://localhost:2368/content/images/size/w600/2022/08/Python_fig_timeseries-1.jpeg 600w, http://localhost:2368/content/images/size/w1000/2022/08/Python_fig_timeseries-1.jpeg 1000w, http://localhost:2368/content/images/size/w1600/2022/08/Python_fig_timeseries-1.jpeg 1600w, http://localhost:2368/content/images/2022/08/Python_fig_timeseries-1.jpeg 1800w" sizes="(min-width: 720px) 720px"><figcaption>Plot of time series data obtained using Python (Pyplot) - Image by author</figcaption></figure><p>Granted, the Python plot needs a bit more manual formatting to have the same look as the MATLAB one. But this is not really an issue once you know what you need to change to get the format you want. You can set the defaults for creating figures on the top of your script, or make a function that does the formatting for new figures.</p><!--kg-card-begin: markdown--><p>If you have trouble getting some details to work, you can just google your answer. The amount of Python users is huge <a href="https://ponder.io/pandas-is-now-as-popular-as-python-was-in-2016/#Python%E2%80%99s%20Popularity%20more%20than%20Doubled%20Between%202013%20and%202022">and growing</a>, so it is very likely you will find someone already asked a similar question online. For instance, I was having a hard time getting the axes titles to show correctly, and there was <a href="https://stackoverflow.com/questions/6774086/how-to-adjust-padding-with-cutoff-or-overlapping-labels">a Stackoverflow thread</a> solving exactly the same issue - turns out you need to add <code>plt.tight_layout()</code> for the figure to be padded correctly. Just part of the learning curve. It&apos;s like when I needed to call the legend in MATLAB as <code>legend(&apos;interpreter&apos;, &apos;none&apos;)</code> to avoid <em>tex</em> interpretation of variable names with underscores, for instance.</p>
<!--kg-card-end: markdown--><p>Plus, this example was done using <a href="https://matplotlib.org/stable/tutorials/introductory/pyplot.html#:~:text=pyplot%20is%20a%20collection%20of,In%20matplotlib.">Pyplot</a>. There are other libraries for plotting, which can produce cleaner plots in different cases, depending on your purposes.</p><hr><p>This post was a bit longer than the others, being the introduction of the series, but I hope you found it helpful or at least interesting. Over the next weeks, I will be sharing other example codes, highlighting the differences between MATLAB and Python, and showing also the things I struggled with. I hope you are motivated to learn Python as I am, and this can be an incentive to try it on your own.</p><p>I will update this first post to index the new examples I include as I go, so it is easier to navigate between the different entries. </p><p>Until the next one!</p><p>Luis</p><p></p><p><em>Edit 2022-09-26:</em> A list of the latest posts in the series:</p><p></p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://makerluis.com/using-matlab-and-statistics-to-analyze-raw-vehicle-data"><div class="kg-bookmark-content"><div class="kg-bookmark-title">Using MATLAB and statistics to analyze raw vehicle data</div><div class="kg-bookmark-description">I am sharing an example of the workflow I would follow for getting insights from real-world data using histograms and some very basic statistics.</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="http://localhost:2368/favicon.ico" alt="Replacing MATLAB with Python - Part 1"><span class="kg-bookmark-author">Making stuff after office hours</span><span class="kg-bookmark-publisher">Luis Medina</span></div></div><div class="kg-bookmark-thumbnail"><img src="https://images.unsplash.com/photo-1512717919743-801d3d85ec83?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDEwOHx8Y2FyJTIwdG95fGVufDB8fHx8MTY2MjMwMTQxMw&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Replacing MATLAB with Python - Part 1"></div></a></figure><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://makerluis.com/replacing-matlab-with-python-part-2"><div class="kg-bookmark-content"><div class="kg-bookmark-title">Replacing MATLAB with Python - Part 2: Formatting subplots and indexing data</div><div class="kg-bookmark-description">I used Python to complete the first part of the task from my previous post in the series. I learned about formatting plots and indexing Pandas dataframes.</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="http://localhost:2368/favicon.ico" alt="Replacing MATLAB with Python - Part 1"><span class="kg-bookmark-author">Making stuff after office hours</span><span class="kg-bookmark-publisher">Luis Medina</span></div></div><div class="kg-bookmark-thumbnail"><img src="https://images.unsplash.com/photo-1551431524-06b3c82d31ca?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDk3fHxrZXlib2FyZHxlbnwwfHx8fDE2NjM1NjQ5NDc&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Replacing MATLAB with Python - Part 1"></div></a></figure>]]></content:encoded></item><item><title><![CDATA[That's it: I'm getting a more reliable 3D printer]]></title><description><![CDATA[Let me tell you about my journey with a cheap 3D printer. It was a ton of fun, and I learned many useful things. Maybe you can learn from my errors too!]]></description><link>http://localhost:2368/that-s-it-i-am-getting-a-more-reliable-3d-printer/</link><guid isPermaLink="false">62c214a0a0cddb69fca4a0c9</guid><category><![CDATA[3dprinting]]></category><category><![CDATA[Blog]]></category><category><![CDATA[Maker]]></category><category><![CDATA[Organization]]></category><category><![CDATA[Plans]]></category><dc:creator><![CDATA[Luis Medina]]></dc:creator><pubDate>Tue, 05 Jul 2022 11:52:28 GMT</pubDate><media:content url="http://localhost:2368/content/images/2022/07/1555354607653-1.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2022/07/1555354607653-1.jpg" alt="That&apos;s it: I&apos;m getting a more reliable 3D printer"><p>In 2019 I finally got my first hobby-grade, FDM 3D printer kit.</p><p>It was a Creality Ender 2, a cantilevered version of the successful Ender 3. It was the perfect fit for a small apartment, requiring a very reduced space to be installed on a desktop. I was really excited when it arrived, assembled it in 30 minutes, and started printing right away. The result of the first print turned out to be a decapitated version of the iconic Maneki-Neko cat, since the filament sample that came with the printer was not enough to complete the test .gcode file. I ended up modeling a head to fit the incomplete print and <a href="https://www.thingiverse.com/thing:3709648">shared it online</a> so that other fellow makers could use it as well.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2022/07/de-capi-cat_1080.jpeg" class="kg-image" alt="That&apos;s it: I&apos;m getting a more reliable 3D printer" loading="lazy" width="1080" height="608" srcset="http://localhost:2368/content/images/size/w600/2022/07/de-capi-cat_1080.jpeg 600w, http://localhost:2368/content/images/size/w1000/2022/07/de-capi-cat_1080.jpeg 1000w, http://localhost:2368/content/images/2022/07/de-capi-cat_1080.jpeg 1080w" sizes="(min-width: 720px) 720px"><figcaption>Although it was a cheap machine, the print quality was actually good!</figcaption></figure><p>At the time, all I wanted to do was to learn more about 3D printing, mod and upgrade my small Ender 2 and see how I could get the best out of such a cheap machine. I was still at university, completing my master&apos;s degree and I had just started working as a research assistant in the Aerosol Technology Laboratory. I had time to tinker around with the printer, right? </p><h3 id="i-had-no-idea-what-i-was-getting-into">I had no idea what I was getting into. </h3><hr><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2022/07/1656957694721.jpg" class="kg-image" alt="That&apos;s it: I&apos;m getting a more reliable 3D printer" loading="lazy"><figcaption>The printer quickly began spreading across the apartment and taking up all my time.</figcaption></figure><p><em><strong>The printer became a Frankenstein and a learning project for me</strong></em>. I switched the printer&apos;s 8-bit mainboard for a <a href="https://www.youtube.com/watch?v=-XUQKQnUNig">32-bit aftermarket one</a>, upgraded the firmware, and installed a part-cooling fan and motor dampers: My first goal was to make it quieter. </p><p>Then I wanted to improve the print quality, so started buying other &quot;budget upgrades&quot;, &#xA0;like a Bondtech BMG knock-off from AliExpress. You see, all the parts I was installing were usually sourced from China, so they were cheap, and took ages to arrive. But buying cheap parts for a cheap printer meant that I wasn&apos;t spending much after all... right? After all, it was working just as well as a much more expensive printer. What&apos;s a couple of euros here and then to make the machine work better? A new print surface to improve bed adhesion. A new set of PTFE tube couplers because the original ones broke...</p><blockquote>But buying cheap parts for a cheap printer meant that I wasn&apos;t spending much after all... right? </blockquote><h3 id="reliability">Reliability</h3><p>It was all good until I started actually wanting to use the printer more consistently during the 2020 COVID-19 lockdown. I printed a bunch of parts for the laboratory I was working on - since we had the equipment, we rushed to provide pre-certification tests for community face masks. Precisely then, I started having serious problems with the prints not adhering to the print bed. I couldn&apos;t launch a print and walk away without having to check every 10 seconds on whether the first layer was OK or not. </p><p>I tried every imaginable solution and read every possible Reddit thread or forum entry about similar problems. Tried different filaments, with different temperatures. Tested different combinations of filaments and heated bed surfaces, and re-leveled the bed a million times. Until I figured out that the bed was warped, and I needed to compensate for that. So I installed an Auto Bed-Leveling Sensor (3D touch) which would probe the bed before each print to compensate for the warped bed. It only worked partially. Some sports were too close to the bed, some too far.</p><p>On top of that, the extrusion started to be very inconsistent. And for various reasons. Sometimes I would fix things by changing the <a href="https://all3dp.com/2/3d-slicer-settings-3d-printer/">slicer parameters</a>. But at some point, even slicer changes wouldn&apos;t help, and I started to find issues with hardware components. One time it was the hot-end heated cartridge not being able to provide enough power. Later on, the extruder gears started making some noise and I found out they were super worn out.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2022/07/cheap_parts.jpg" class="kg-image" alt="That&apos;s it: I&apos;m getting a more reliable 3D printer" loading="lazy" width="2000" height="1000" srcset="http://localhost:2368/content/images/size/w600/2022/07/cheap_parts.jpg 600w, http://localhost:2368/content/images/size/w1000/2022/07/cheap_parts.jpg 1000w, http://localhost:2368/content/images/size/w1600/2022/07/cheap_parts.jpg 1600w, http://localhost:2368/content/images/size/w2400/2022/07/cheap_parts.jpg 2400w" sizes="(min-width: 720px) 720px"><figcaption>Using cheap parts for any kind of machine will cause wear and damage that stacks up over time.&#xA0;</figcaption></figure><p>When I look back at the orders for upgrades and replacement components I made through AliExpress, Amazon, 3D Jake and eBay combined, I realize that the total is <strong>&#x20AC; 314</strong>! That is almost twice the price I paid for the printer itself, and it&apos;s not including the time I spent working on it, and reading online to figure out how to solve the problems I found.</p><h3 id="i-made-a-list-with-all-the-components-i-bought-for-the-printer-their-price-intended-use-and-how-effective-those-upgrades-were">I made a list with all the components i bought for the printer, their price, intended use, and how effective those upgrades were. </h3><p>Unfortunately, I have lost all the data I collected about noise levels, number of successful first layers, bed level meshes, and so on. But I still think the list can be useful for someone starting with 3D printing as I did.</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://docs.google.com/spreadsheets/d/e/2PACX-1vRbaN-palKJxYJrWByL81tRWoCOp3J-rLvDKy4rkkflUw2AZGiksLXhdY6Pu7yNdmAlveUorZ8s4I3s/pubhtml"><div class="kg-bookmark-content"><div class="kg-bookmark-title">Ender 2 - Modding and running costs - Google Drive</div><div class="kg-bookmark-description"></div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://ssl.gstatic.com/docs/spreadsheets/favicon3.ico" alt="That&apos;s it: I&apos;m getting a more reliable 3D printer"><span class="kg-bookmark-author">Google Drive</span></div></div></a></figure><hr><h3 id="it-all-comes-down-to-what-your-plans-are-and-how-you-value-your-time-and-money">It all comes down to what your plans are, and how you value your time and money</h3><p>In retrospect, the process of calibrating and upgrading the old Ender 2 and &quot;fighting&quot; to make it work better was an invaluable learning experience for me. I followed a bunch of <a href="https://teachingtechyt.github.io/calibration.html">useful online guides</a> and learned about how awesome the maker community is online. I now understand a lot more about how 3D printers work: the Marlin software, extruder types, motion systems, &#xA0;stepper motors, power supply units, and got a lot of experience with slicer parameters. It was really a ton of fun too.</p><p>So now, when someone asks me: &quot;should I get a 3D printer? How much should I spend on it?&quot;, the answer is, of course, a big: <em><strong>it depends</strong></em>. </p><p>What do you want to use it for? If you need consistency out of the box, maybe even a cheap Creality machine will do. If you need reliability and quality out of the box, you&apos;ll need a bigger budget for sure. </p><p>If you just want the printer for hobby use, then ask yourself: Do I want to tinker with the printer as a hobby, and am I willing to spend time learning about how it works? or do I want to use the printer to produce parts for my actual hobby?</p><p>That&apos;s where I made the decision to get a new one. Now I just need something to print consistently, since I no longer have all the time I had as a student. Plus, the Ender 2 has been discontinued, which means that replacement parts are no longer being produced. This is especially bad for the warped heated bed which had me struggling for the last couple of months. For reference, look at this plot I made with the data from a G29 command (the glass bed was installed!):</p><!--kg-card-begin: html--><iframe width="900" height="450" frameborder="0" scrolling="no" src="test_mesh.html"></iframe><!--kg-card-end: html--><blockquote class="kg-blockquote-alt">For my current needs, I&apos;d rather have a printer that just works to make stuff for my actual hobbies. I think I&apos;ve learned the basics quite well now.</blockquote><p>By the way, some people were interested in the code I used to make plot shown above, so here is the python script :)</p><!--kg-card-begin: html--><script src="https://gist.github.com/luisdamed/68b714d312633b18507ca6cefc0a3bff.js"></script><!--kg-card-end: html-->]]></content:encoded></item><item><title><![CDATA[Hello world! Welcome to my blog]]></title><description><![CDATA[Hi! My name is Luis and I make stuff when I am not working my full-time office job. I will use this site to document some of the projects I have done and share things I have learned along my path, that might be interesting for you.]]></description><link>http://localhost:2368/hello-world-welcome-to-my-blog/</link><guid isPermaLink="false">62bd77e5d5160781b40f715d</guid><category><![CDATA[Maker]]></category><category><![CDATA[Plans]]></category><category><![CDATA[Organization]]></category><category><![CDATA[CAD]]></category><category><![CDATA[Electronics]]></category><category><![CDATA[EsP32]]></category><category><![CDATA[3dprinting]]></category><category><![CDATA[Python]]></category><dc:creator><![CDATA[Luis Medina]]></dc:creator><pubDate>Thu, 30 Jun 2022 10:16:05 GMT</pubDate><media:content url="http://localhost:2368/content/images/2022/06/Portacoronas-23-15.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2022/06/Portacoronas-23-15.jpg" alt="Hello world! Welcome to my blog"><p>Hi! As you might have guessed by the site name, my name is Luis and I make stuff when I am not working my full-time office job. I am a Mechanical and Automotive Engineering graduate, but I have always loved making things at home: sometimes just drawings, paintings, or small sculptures. And sometimes I do more technical stuff, like python scripts, small electronic projects with ESP8266 or ESP32, 3D printed objects... you get the idea. I make stuff.</p><p>People who have known me at different moments of my life might remember me for different aspects. For instance:</p><ul><li>In school, I used to be the guy doing hand sketches and drawings</li><li>During my first years of university, I was the guy obsessed with 3D CAD modeling</li><li>While completing my master&apos;s studies, I was the guy who wanted to learn everything about FEM stress analysis - and actually wrote my thesis almost 80% around that.</li></ul><p>But now, 2 years after graduating, I realize that what I really enjoy is learning new stuff and applying it to real problems. If you asked my friends from university almost none of them would think I&apos;d be interested in data analysis, electronics, sensors, IoT, and all that kinds of things. But here I am :) &#xA0;It&apos;s a random mix, for now.</p><p>I plan to use this site to share things that I have learned and little projects that I do in my spare time. Hopefully decently documented so you might find something useful or at least interesting. I might also share more engineering-related content about things I&apos;ve done in the past. There is a double-fold benefit for me: I also plan to use this to organize myself better and have a more structured way to actually complete the projects I start.</p><p>Now, from all the things I will post, about 80% are self-learned, and I am in absolutely no way an expert on any of the topics I will discuss here, but at least I will do my best to point you guys out to useful resources I used for learning myself.</p><p>I have been meaning to publish this for some time now, and I have finally done it (during a week of COVID-19 home isolation). </p><p>Wish me luck! and I hope you have a great day!</p><p></p><p></p><p></p><p></p>]]></content:encoded></item></channel></rss>